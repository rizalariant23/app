module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAuction {
  count: Int!
}

type AggregateAuthPayload {
  count: Int!
}

type AggregateBid {
  count: Int!
}

type AggregateBird {
  count: Int!
}

type AggregateBirdParent {
  count: Int!
}

type AggregateBreedingLog {
  count: Int!
}

type AggregateBreedingRecord {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateJournal {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Auction {
  id: ID!
  bird: Bird!
  seller: User!
  openPrice: String!
  closePrice: String!
  incrementAmount: String!
  startTime: String!
  closeTime: String!
  bids(where: BidWhereInput, orderBy: BidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bid!]
  lastBid: Bid
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  isClosed: Boolean!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type AuctionConnection {
  pageInfo: PageInfo!
  edges: [AuctionEdge]!
  aggregate: AggregateAuction!
}

input AuctionCreateInput {
  id: ID
  bird: BirdCreateOneInput!
  seller: UserCreateOneWithoutAuctionsInput!
  openPrice: String!
  closePrice: String!
  incrementAmount: String!
  startTime: String!
  closeTime: String!
  bids: BidCreateManyInput
  lastBid: BidCreateOneInput
  comments: CommentCreateManyWithoutAuctionInput
  isClosed: Boolean
}

input AuctionCreateManyWithoutSellerInput {
  create: [AuctionCreateWithoutSellerInput!]
  connect: [AuctionWhereUniqueInput!]
}

input AuctionCreateOneInput {
  create: AuctionCreateInput
  connect: AuctionWhereUniqueInput
}

input AuctionCreateOneWithoutCommentsInput {
  create: AuctionCreateWithoutCommentsInput
  connect: AuctionWhereUniqueInput
}

input AuctionCreateWithoutCommentsInput {
  id: ID
  bird: BirdCreateOneInput!
  seller: UserCreateOneWithoutAuctionsInput!
  openPrice: String!
  closePrice: String!
  incrementAmount: String!
  startTime: String!
  closeTime: String!
  bids: BidCreateManyInput
  lastBid: BidCreateOneInput
  isClosed: Boolean
}

input AuctionCreateWithoutSellerInput {
  id: ID
  bird: BirdCreateOneInput!
  openPrice: String!
  closePrice: String!
  incrementAmount: String!
  startTime: String!
  closeTime: String!
  bids: BidCreateManyInput
  lastBid: BidCreateOneInput
  comments: CommentCreateManyWithoutAuctionInput
  isClosed: Boolean
}

type AuctionEdge {
  node: Auction!
  cursor: String!
}

enum AuctionOrderByInput {
  id_ASC
  id_DESC
  openPrice_ASC
  openPrice_DESC
  closePrice_ASC
  closePrice_DESC
  incrementAmount_ASC
  incrementAmount_DESC
  startTime_ASC
  startTime_DESC
  closeTime_ASC
  closeTime_DESC
  isClosed_ASC
  isClosed_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AuctionPreviousValues {
  id: ID!
  openPrice: String!
  closePrice: String!
  incrementAmount: String!
  startTime: String!
  closeTime: String!
  isClosed: Boolean!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input AuctionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  openPrice: String
  openPrice_not: String
  openPrice_in: [String!]
  openPrice_not_in: [String!]
  openPrice_lt: String
  openPrice_lte: String
  openPrice_gt: String
  openPrice_gte: String
  openPrice_contains: String
  openPrice_not_contains: String
  openPrice_starts_with: String
  openPrice_not_starts_with: String
  openPrice_ends_with: String
  openPrice_not_ends_with: String
  closePrice: String
  closePrice_not: String
  closePrice_in: [String!]
  closePrice_not_in: [String!]
  closePrice_lt: String
  closePrice_lte: String
  closePrice_gt: String
  closePrice_gte: String
  closePrice_contains: String
  closePrice_not_contains: String
  closePrice_starts_with: String
  closePrice_not_starts_with: String
  closePrice_ends_with: String
  closePrice_not_ends_with: String
  incrementAmount: String
  incrementAmount_not: String
  incrementAmount_in: [String!]
  incrementAmount_not_in: [String!]
  incrementAmount_lt: String
  incrementAmount_lte: String
  incrementAmount_gt: String
  incrementAmount_gte: String
  incrementAmount_contains: String
  incrementAmount_not_contains: String
  incrementAmount_starts_with: String
  incrementAmount_not_starts_with: String
  incrementAmount_ends_with: String
  incrementAmount_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  closeTime: String
  closeTime_not: String
  closeTime_in: [String!]
  closeTime_not_in: [String!]
  closeTime_lt: String
  closeTime_lte: String
  closeTime_gt: String
  closeTime_gte: String
  closeTime_contains: String
  closeTime_not_contains: String
  closeTime_starts_with: String
  closeTime_not_starts_with: String
  closeTime_ends_with: String
  closeTime_not_ends_with: String
  isClosed: Boolean
  isClosed_not: Boolean
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AuctionScalarWhereInput!]
  OR: [AuctionScalarWhereInput!]
  NOT: [AuctionScalarWhereInput!]
}

type AuctionSubscriptionPayload {
  mutation: MutationType!
  node: Auction
  updatedFields: [String!]
  previousValues: AuctionPreviousValues
}

input AuctionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AuctionWhereInput
  AND: [AuctionSubscriptionWhereInput!]
  OR: [AuctionSubscriptionWhereInput!]
  NOT: [AuctionSubscriptionWhereInput!]
}

input AuctionUpdateDataInput {
  bird: BirdUpdateOneRequiredInput
  seller: UserUpdateOneRequiredWithoutAuctionsInput
  openPrice: String
  closePrice: String
  incrementAmount: String
  startTime: String
  closeTime: String
  bids: BidUpdateManyInput
  lastBid: BidUpdateOneInput
  comments: CommentUpdateManyWithoutAuctionInput
  isClosed: Boolean
}

input AuctionUpdateInput {
  bird: BirdUpdateOneRequiredInput
  seller: UserUpdateOneRequiredWithoutAuctionsInput
  openPrice: String
  closePrice: String
  incrementAmount: String
  startTime: String
  closeTime: String
  bids: BidUpdateManyInput
  lastBid: BidUpdateOneInput
  comments: CommentUpdateManyWithoutAuctionInput
  isClosed: Boolean
}

input AuctionUpdateManyDataInput {
  openPrice: String
  closePrice: String
  incrementAmount: String
  startTime: String
  closeTime: String
  isClosed: Boolean
}

input AuctionUpdateManyMutationInput {
  openPrice: String
  closePrice: String
  incrementAmount: String
  startTime: String
  closeTime: String
  isClosed: Boolean
}

input AuctionUpdateManyWithoutSellerInput {
  create: [AuctionCreateWithoutSellerInput!]
  delete: [AuctionWhereUniqueInput!]
  connect: [AuctionWhereUniqueInput!]
  set: [AuctionWhereUniqueInput!]
  disconnect: [AuctionWhereUniqueInput!]
  update: [AuctionUpdateWithWhereUniqueWithoutSellerInput!]
  upsert: [AuctionUpsertWithWhereUniqueWithoutSellerInput!]
  deleteMany: [AuctionScalarWhereInput!]
  updateMany: [AuctionUpdateManyWithWhereNestedInput!]
}

input AuctionUpdateManyWithWhereNestedInput {
  where: AuctionScalarWhereInput!
  data: AuctionUpdateManyDataInput!
}

input AuctionUpdateOneRequiredInput {
  create: AuctionCreateInput
  update: AuctionUpdateDataInput
  upsert: AuctionUpsertNestedInput
  connect: AuctionWhereUniqueInput
}

input AuctionUpdateOneRequiredWithoutCommentsInput {
  create: AuctionCreateWithoutCommentsInput
  update: AuctionUpdateWithoutCommentsDataInput
  upsert: AuctionUpsertWithoutCommentsInput
  connect: AuctionWhereUniqueInput
}

input AuctionUpdateWithoutCommentsDataInput {
  bird: BirdUpdateOneRequiredInput
  seller: UserUpdateOneRequiredWithoutAuctionsInput
  openPrice: String
  closePrice: String
  incrementAmount: String
  startTime: String
  closeTime: String
  bids: BidUpdateManyInput
  lastBid: BidUpdateOneInput
  isClosed: Boolean
}

input AuctionUpdateWithoutSellerDataInput {
  bird: BirdUpdateOneRequiredInput
  openPrice: String
  closePrice: String
  incrementAmount: String
  startTime: String
  closeTime: String
  bids: BidUpdateManyInput
  lastBid: BidUpdateOneInput
  comments: CommentUpdateManyWithoutAuctionInput
  isClosed: Boolean
}

input AuctionUpdateWithWhereUniqueWithoutSellerInput {
  where: AuctionWhereUniqueInput!
  data: AuctionUpdateWithoutSellerDataInput!
}

input AuctionUpsertNestedInput {
  update: AuctionUpdateDataInput!
  create: AuctionCreateInput!
}

input AuctionUpsertWithoutCommentsInput {
  update: AuctionUpdateWithoutCommentsDataInput!
  create: AuctionCreateWithoutCommentsInput!
}

input AuctionUpsertWithWhereUniqueWithoutSellerInput {
  where: AuctionWhereUniqueInput!
  update: AuctionUpdateWithoutSellerDataInput!
  create: AuctionCreateWithoutSellerInput!
}

input AuctionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  bird: BirdWhereInput
  seller: UserWhereInput
  openPrice: String
  openPrice_not: String
  openPrice_in: [String!]
  openPrice_not_in: [String!]
  openPrice_lt: String
  openPrice_lte: String
  openPrice_gt: String
  openPrice_gte: String
  openPrice_contains: String
  openPrice_not_contains: String
  openPrice_starts_with: String
  openPrice_not_starts_with: String
  openPrice_ends_with: String
  openPrice_not_ends_with: String
  closePrice: String
  closePrice_not: String
  closePrice_in: [String!]
  closePrice_not_in: [String!]
  closePrice_lt: String
  closePrice_lte: String
  closePrice_gt: String
  closePrice_gte: String
  closePrice_contains: String
  closePrice_not_contains: String
  closePrice_starts_with: String
  closePrice_not_starts_with: String
  closePrice_ends_with: String
  closePrice_not_ends_with: String
  incrementAmount: String
  incrementAmount_not: String
  incrementAmount_in: [String!]
  incrementAmount_not_in: [String!]
  incrementAmount_lt: String
  incrementAmount_lte: String
  incrementAmount_gt: String
  incrementAmount_gte: String
  incrementAmount_contains: String
  incrementAmount_not_contains: String
  incrementAmount_starts_with: String
  incrementAmount_not_starts_with: String
  incrementAmount_ends_with: String
  incrementAmount_not_ends_with: String
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  closeTime: String
  closeTime_not: String
  closeTime_in: [String!]
  closeTime_not_in: [String!]
  closeTime_lt: String
  closeTime_lte: String
  closeTime_gt: String
  closeTime_gte: String
  closeTime_contains: String
  closeTime_not_contains: String
  closeTime_starts_with: String
  closeTime_not_starts_with: String
  closeTime_ends_with: String
  closeTime_not_ends_with: String
  bids_every: BidWhereInput
  bids_some: BidWhereInput
  bids_none: BidWhereInput
  lastBid: BidWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  isClosed: Boolean
  isClosed_not: Boolean
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AuctionWhereInput!]
  OR: [AuctionWhereInput!]
  NOT: [AuctionWhereInput!]
}

input AuctionWhereUniqueInput {
  id: ID
}

type AuthPayload {
  id: ID!
  token: String
  user: User
  updatedAt: DateTime!
  createdAt: DateTime!
}

type AuthPayloadConnection {
  pageInfo: PageInfo!
  edges: [AuthPayloadEdge]!
  aggregate: AggregateAuthPayload!
}

input AuthPayloadCreateInput {
  id: ID
  token: String
  user: UserCreateOneInput
}

type AuthPayloadEdge {
  node: AuthPayload!
  cursor: String!
}

enum AuthPayloadOrderByInput {
  id_ASC
  id_DESC
  token_ASC
  token_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AuthPayloadPreviousValues {
  id: ID!
  token: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

type AuthPayloadSubscriptionPayload {
  mutation: MutationType!
  node: AuthPayload
  updatedFields: [String!]
  previousValues: AuthPayloadPreviousValues
}

input AuthPayloadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AuthPayloadWhereInput
  AND: [AuthPayloadSubscriptionWhereInput!]
  OR: [AuthPayloadSubscriptionWhereInput!]
  NOT: [AuthPayloadSubscriptionWhereInput!]
}

input AuthPayloadUpdateInput {
  token: String
  user: UserUpdateOneInput
}

input AuthPayloadUpdateManyMutationInput {
  token: String
}

input AuthPayloadWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  user: UserWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AuthPayloadWhereInput!]
  OR: [AuthPayloadWhereInput!]
  NOT: [AuthPayloadWhereInput!]
}

input AuthPayloadWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Bid {
  id: ID!
  auction: Auction!
  bidder: User!
  amountBid: String!
  timeStamp: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type BidConnection {
  pageInfo: PageInfo!
  edges: [BidEdge]!
  aggregate: AggregateBid!
}

input BidCreateInput {
  id: ID
  auction: AuctionCreateOneInput!
  bidder: UserCreateOneWithoutBidsInput!
  amountBid: String!
  timeStamp: String!
}

input BidCreateManyInput {
  create: [BidCreateInput!]
  connect: [BidWhereUniqueInput!]
}

input BidCreateManyWithoutBidderInput {
  create: [BidCreateWithoutBidderInput!]
  connect: [BidWhereUniqueInput!]
}

input BidCreateOneInput {
  create: BidCreateInput
  connect: BidWhereUniqueInput
}

input BidCreateWithoutBidderInput {
  id: ID
  auction: AuctionCreateOneInput!
  amountBid: String!
  timeStamp: String!
}

type BidEdge {
  node: Bid!
  cursor: String!
}

enum BidOrderByInput {
  id_ASC
  id_DESC
  amountBid_ASC
  amountBid_DESC
  timeStamp_ASC
  timeStamp_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BidPreviousValues {
  id: ID!
  amountBid: String!
  timeStamp: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input BidScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amountBid: String
  amountBid_not: String
  amountBid_in: [String!]
  amountBid_not_in: [String!]
  amountBid_lt: String
  amountBid_lte: String
  amountBid_gt: String
  amountBid_gte: String
  amountBid_contains: String
  amountBid_not_contains: String
  amountBid_starts_with: String
  amountBid_not_starts_with: String
  amountBid_ends_with: String
  amountBid_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BidScalarWhereInput!]
  OR: [BidScalarWhereInput!]
  NOT: [BidScalarWhereInput!]
}

type BidSubscriptionPayload {
  mutation: MutationType!
  node: Bid
  updatedFields: [String!]
  previousValues: BidPreviousValues
}

input BidSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BidWhereInput
  AND: [BidSubscriptionWhereInput!]
  OR: [BidSubscriptionWhereInput!]
  NOT: [BidSubscriptionWhereInput!]
}

input BidUpdateDataInput {
  auction: AuctionUpdateOneRequiredInput
  bidder: UserUpdateOneRequiredWithoutBidsInput
  amountBid: String
  timeStamp: String
}

input BidUpdateInput {
  auction: AuctionUpdateOneRequiredInput
  bidder: UserUpdateOneRequiredWithoutBidsInput
  amountBid: String
  timeStamp: String
}

input BidUpdateManyDataInput {
  amountBid: String
  timeStamp: String
}

input BidUpdateManyInput {
  create: [BidCreateInput!]
  update: [BidUpdateWithWhereUniqueNestedInput!]
  upsert: [BidUpsertWithWhereUniqueNestedInput!]
  delete: [BidWhereUniqueInput!]
  connect: [BidWhereUniqueInput!]
  set: [BidWhereUniqueInput!]
  disconnect: [BidWhereUniqueInput!]
  deleteMany: [BidScalarWhereInput!]
  updateMany: [BidUpdateManyWithWhereNestedInput!]
}

input BidUpdateManyMutationInput {
  amountBid: String
  timeStamp: String
}

input BidUpdateManyWithoutBidderInput {
  create: [BidCreateWithoutBidderInput!]
  delete: [BidWhereUniqueInput!]
  connect: [BidWhereUniqueInput!]
  set: [BidWhereUniqueInput!]
  disconnect: [BidWhereUniqueInput!]
  update: [BidUpdateWithWhereUniqueWithoutBidderInput!]
  upsert: [BidUpsertWithWhereUniqueWithoutBidderInput!]
  deleteMany: [BidScalarWhereInput!]
  updateMany: [BidUpdateManyWithWhereNestedInput!]
}

input BidUpdateManyWithWhereNestedInput {
  where: BidScalarWhereInput!
  data: BidUpdateManyDataInput!
}

input BidUpdateOneInput {
  create: BidCreateInput
  update: BidUpdateDataInput
  upsert: BidUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BidWhereUniqueInput
}

input BidUpdateWithoutBidderDataInput {
  auction: AuctionUpdateOneRequiredInput
  amountBid: String
  timeStamp: String
}

input BidUpdateWithWhereUniqueNestedInput {
  where: BidWhereUniqueInput!
  data: BidUpdateDataInput!
}

input BidUpdateWithWhereUniqueWithoutBidderInput {
  where: BidWhereUniqueInput!
  data: BidUpdateWithoutBidderDataInput!
}

input BidUpsertNestedInput {
  update: BidUpdateDataInput!
  create: BidCreateInput!
}

input BidUpsertWithWhereUniqueNestedInput {
  where: BidWhereUniqueInput!
  update: BidUpdateDataInput!
  create: BidCreateInput!
}

input BidUpsertWithWhereUniqueWithoutBidderInput {
  where: BidWhereUniqueInput!
  update: BidUpdateWithoutBidderDataInput!
  create: BidCreateWithoutBidderInput!
}

input BidWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  auction: AuctionWhereInput
  bidder: UserWhereInput
  amountBid: String
  amountBid_not: String
  amountBid_in: [String!]
  amountBid_not_in: [String!]
  amountBid_lt: String
  amountBid_lte: String
  amountBid_gt: String
  amountBid_gte: String
  amountBid_contains: String
  amountBid_not_contains: String
  amountBid_starts_with: String
  amountBid_not_starts_with: String
  amountBid_ends_with: String
  amountBid_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BidWhereInput!]
  OR: [BidWhereInput!]
  NOT: [BidWhereInput!]
}

input BidWhereUniqueInput {
  id: ID
}

type Bird {
  id: ID!
  name: String
  ring: String!
  owner: User!
  breeder: String!
  species: String!
  type: String!
  gender: String!
  age: String!
  image(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  parent: BirdParent
  dna: Image
  updatedAt: DateTime!
  createdAt: DateTime!
}

type BirdConnection {
  pageInfo: PageInfo!
  edges: [BirdEdge]!
  aggregate: AggregateBird!
}

input BirdCreateInput {
  id: ID
  name: String
  ring: String!
  owner: UserCreateOneWithoutBirdOwnedInput!
  breeder: String!
  species: String!
  type: String!
  gender: String!
  age: String!
  image: ImageCreateManyInput
  parent: BirdParentCreateOneInput
  dna: ImageCreateOneInput
}

input BirdCreateManyWithoutOwnerInput {
  create: [BirdCreateWithoutOwnerInput!]
  connect: [BirdWhereUniqueInput!]
}

input BirdCreateOneInput {
  create: BirdCreateInput
  connect: BirdWhereUniqueInput
}

input BirdCreateWithoutOwnerInput {
  id: ID
  name: String
  ring: String!
  breeder: String!
  species: String!
  type: String!
  gender: String!
  age: String!
  image: ImageCreateManyInput
  parent: BirdParentCreateOneInput
  dna: ImageCreateOneInput
}

type BirdEdge {
  node: Bird!
  cursor: String!
}

enum BirdOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  ring_ASC
  ring_DESC
  breeder_ASC
  breeder_DESC
  species_ASC
  species_DESC
  type_ASC
  type_DESC
  gender_ASC
  gender_DESC
  age_ASC
  age_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BirdParent {
  id: ID!
  noParent: String!
  breedingRecord(where: BreedingRecordWhereInput, orderBy: BreedingRecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BreedingRecord!]
  male: Bird!
  female: Bird!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type BirdParentConnection {
  pageInfo: PageInfo!
  edges: [BirdParentEdge]!
  aggregate: AggregateBirdParent!
}

input BirdParentCreateInput {
  id: ID
  noParent: String!
  breedingRecord: BreedingRecordCreateManyWithoutParentInput
  male: BirdCreateOneInput!
  female: BirdCreateOneInput!
}

input BirdParentCreateManyInput {
  create: [BirdParentCreateInput!]
  connect: [BirdParentWhereUniqueInput!]
}

input BirdParentCreateOneInput {
  create: BirdParentCreateInput
  connect: BirdParentWhereUniqueInput
}

input BirdParentCreateOneWithoutBreedingRecordInput {
  create: BirdParentCreateWithoutBreedingRecordInput
  connect: BirdParentWhereUniqueInput
}

input BirdParentCreateWithoutBreedingRecordInput {
  id: ID
  noParent: String!
  male: BirdCreateOneInput!
  female: BirdCreateOneInput!
}

type BirdParentEdge {
  node: BirdParent!
  cursor: String!
}

enum BirdParentOrderByInput {
  id_ASC
  id_DESC
  noParent_ASC
  noParent_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BirdParentPreviousValues {
  id: ID!
  noParent: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input BirdParentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  noParent: String
  noParent_not: String
  noParent_in: [String!]
  noParent_not_in: [String!]
  noParent_lt: String
  noParent_lte: String
  noParent_gt: String
  noParent_gte: String
  noParent_contains: String
  noParent_not_contains: String
  noParent_starts_with: String
  noParent_not_starts_with: String
  noParent_ends_with: String
  noParent_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BirdParentScalarWhereInput!]
  OR: [BirdParentScalarWhereInput!]
  NOT: [BirdParentScalarWhereInput!]
}

type BirdParentSubscriptionPayload {
  mutation: MutationType!
  node: BirdParent
  updatedFields: [String!]
  previousValues: BirdParentPreviousValues
}

input BirdParentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BirdParentWhereInput
  AND: [BirdParentSubscriptionWhereInput!]
  OR: [BirdParentSubscriptionWhereInput!]
  NOT: [BirdParentSubscriptionWhereInput!]
}

input BirdParentUpdateDataInput {
  noParent: String
  breedingRecord: BreedingRecordUpdateManyWithoutParentInput
  male: BirdUpdateOneRequiredInput
  female: BirdUpdateOneRequiredInput
}

input BirdParentUpdateInput {
  noParent: String
  breedingRecord: BreedingRecordUpdateManyWithoutParentInput
  male: BirdUpdateOneRequiredInput
  female: BirdUpdateOneRequiredInput
}

input BirdParentUpdateManyDataInput {
  noParent: String
}

input BirdParentUpdateManyInput {
  create: [BirdParentCreateInput!]
  update: [BirdParentUpdateWithWhereUniqueNestedInput!]
  upsert: [BirdParentUpsertWithWhereUniqueNestedInput!]
  delete: [BirdParentWhereUniqueInput!]
  connect: [BirdParentWhereUniqueInput!]
  set: [BirdParentWhereUniqueInput!]
  disconnect: [BirdParentWhereUniqueInput!]
  deleteMany: [BirdParentScalarWhereInput!]
  updateMany: [BirdParentUpdateManyWithWhereNestedInput!]
}

input BirdParentUpdateManyMutationInput {
  noParent: String
}

input BirdParentUpdateManyWithWhereNestedInput {
  where: BirdParentScalarWhereInput!
  data: BirdParentUpdateManyDataInput!
}

input BirdParentUpdateOneInput {
  create: BirdParentCreateInput
  update: BirdParentUpdateDataInput
  upsert: BirdParentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BirdParentWhereUniqueInput
}

input BirdParentUpdateOneWithoutBreedingRecordInput {
  create: BirdParentCreateWithoutBreedingRecordInput
  update: BirdParentUpdateWithoutBreedingRecordDataInput
  upsert: BirdParentUpsertWithoutBreedingRecordInput
  delete: Boolean
  disconnect: Boolean
  connect: BirdParentWhereUniqueInput
}

input BirdParentUpdateWithoutBreedingRecordDataInput {
  noParent: String
  male: BirdUpdateOneRequiredInput
  female: BirdUpdateOneRequiredInput
}

input BirdParentUpdateWithWhereUniqueNestedInput {
  where: BirdParentWhereUniqueInput!
  data: BirdParentUpdateDataInput!
}

input BirdParentUpsertNestedInput {
  update: BirdParentUpdateDataInput!
  create: BirdParentCreateInput!
}

input BirdParentUpsertWithoutBreedingRecordInput {
  update: BirdParentUpdateWithoutBreedingRecordDataInput!
  create: BirdParentCreateWithoutBreedingRecordInput!
}

input BirdParentUpsertWithWhereUniqueNestedInput {
  where: BirdParentWhereUniqueInput!
  update: BirdParentUpdateDataInput!
  create: BirdParentCreateInput!
}

input BirdParentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  noParent: String
  noParent_not: String
  noParent_in: [String!]
  noParent_not_in: [String!]
  noParent_lt: String
  noParent_lte: String
  noParent_gt: String
  noParent_gte: String
  noParent_contains: String
  noParent_not_contains: String
  noParent_starts_with: String
  noParent_not_starts_with: String
  noParent_ends_with: String
  noParent_not_ends_with: String
  breedingRecord_every: BreedingRecordWhereInput
  breedingRecord_some: BreedingRecordWhereInput
  breedingRecord_none: BreedingRecordWhereInput
  male: BirdWhereInput
  female: BirdWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BirdParentWhereInput!]
  OR: [BirdParentWhereInput!]
  NOT: [BirdParentWhereInput!]
}

input BirdParentWhereUniqueInput {
  id: ID
}

type BirdPreviousValues {
  id: ID!
  name: String
  ring: String!
  breeder: String!
  species: String!
  type: String!
  gender: String!
  age: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input BirdScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  ring: String
  ring_not: String
  ring_in: [String!]
  ring_not_in: [String!]
  ring_lt: String
  ring_lte: String
  ring_gt: String
  ring_gte: String
  ring_contains: String
  ring_not_contains: String
  ring_starts_with: String
  ring_not_starts_with: String
  ring_ends_with: String
  ring_not_ends_with: String
  breeder: String
  breeder_not: String
  breeder_in: [String!]
  breeder_not_in: [String!]
  breeder_lt: String
  breeder_lte: String
  breeder_gt: String
  breeder_gte: String
  breeder_contains: String
  breeder_not_contains: String
  breeder_starts_with: String
  breeder_not_starts_with: String
  breeder_ends_with: String
  breeder_not_ends_with: String
  species: String
  species_not: String
  species_in: [String!]
  species_not_in: [String!]
  species_lt: String
  species_lte: String
  species_gt: String
  species_gte: String
  species_contains: String
  species_not_contains: String
  species_starts_with: String
  species_not_starts_with: String
  species_ends_with: String
  species_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  age: String
  age_not: String
  age_in: [String!]
  age_not_in: [String!]
  age_lt: String
  age_lte: String
  age_gt: String
  age_gte: String
  age_contains: String
  age_not_contains: String
  age_starts_with: String
  age_not_starts_with: String
  age_ends_with: String
  age_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BirdScalarWhereInput!]
  OR: [BirdScalarWhereInput!]
  NOT: [BirdScalarWhereInput!]
}

type BirdSubscriptionPayload {
  mutation: MutationType!
  node: Bird
  updatedFields: [String!]
  previousValues: BirdPreviousValues
}

input BirdSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BirdWhereInput
  AND: [BirdSubscriptionWhereInput!]
  OR: [BirdSubscriptionWhereInput!]
  NOT: [BirdSubscriptionWhereInput!]
}

input BirdUpdateDataInput {
  name: String
  ring: String
  owner: UserUpdateOneRequiredWithoutBirdOwnedInput
  breeder: String
  species: String
  type: String
  gender: String
  age: String
  image: ImageUpdateManyInput
  parent: BirdParentUpdateOneInput
  dna: ImageUpdateOneInput
}

input BirdUpdateInput {
  name: String
  ring: String
  owner: UserUpdateOneRequiredWithoutBirdOwnedInput
  breeder: String
  species: String
  type: String
  gender: String
  age: String
  image: ImageUpdateManyInput
  parent: BirdParentUpdateOneInput
  dna: ImageUpdateOneInput
}

input BirdUpdateManyDataInput {
  name: String
  ring: String
  breeder: String
  species: String
  type: String
  gender: String
  age: String
}

input BirdUpdateManyMutationInput {
  name: String
  ring: String
  breeder: String
  species: String
  type: String
  gender: String
  age: String
}

input BirdUpdateManyWithoutOwnerInput {
  create: [BirdCreateWithoutOwnerInput!]
  delete: [BirdWhereUniqueInput!]
  connect: [BirdWhereUniqueInput!]
  set: [BirdWhereUniqueInput!]
  disconnect: [BirdWhereUniqueInput!]
  update: [BirdUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [BirdUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [BirdScalarWhereInput!]
  updateMany: [BirdUpdateManyWithWhereNestedInput!]
}

input BirdUpdateManyWithWhereNestedInput {
  where: BirdScalarWhereInput!
  data: BirdUpdateManyDataInput!
}

input BirdUpdateOneRequiredInput {
  create: BirdCreateInput
  update: BirdUpdateDataInput
  upsert: BirdUpsertNestedInput
  connect: BirdWhereUniqueInput
}

input BirdUpdateWithoutOwnerDataInput {
  name: String
  ring: String
  breeder: String
  species: String
  type: String
  gender: String
  age: String
  image: ImageUpdateManyInput
  parent: BirdParentUpdateOneInput
  dna: ImageUpdateOneInput
}

input BirdUpdateWithWhereUniqueWithoutOwnerInput {
  where: BirdWhereUniqueInput!
  data: BirdUpdateWithoutOwnerDataInput!
}

input BirdUpsertNestedInput {
  update: BirdUpdateDataInput!
  create: BirdCreateInput!
}

input BirdUpsertWithWhereUniqueWithoutOwnerInput {
  where: BirdWhereUniqueInput!
  update: BirdUpdateWithoutOwnerDataInput!
  create: BirdCreateWithoutOwnerInput!
}

input BirdWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  ring: String
  ring_not: String
  ring_in: [String!]
  ring_not_in: [String!]
  ring_lt: String
  ring_lte: String
  ring_gt: String
  ring_gte: String
  ring_contains: String
  ring_not_contains: String
  ring_starts_with: String
  ring_not_starts_with: String
  ring_ends_with: String
  ring_not_ends_with: String
  owner: UserWhereInput
  breeder: String
  breeder_not: String
  breeder_in: [String!]
  breeder_not_in: [String!]
  breeder_lt: String
  breeder_lte: String
  breeder_gt: String
  breeder_gte: String
  breeder_contains: String
  breeder_not_contains: String
  breeder_starts_with: String
  breeder_not_starts_with: String
  breeder_ends_with: String
  breeder_not_ends_with: String
  species: String
  species_not: String
  species_in: [String!]
  species_not_in: [String!]
  species_lt: String
  species_lte: String
  species_gt: String
  species_gte: String
  species_contains: String
  species_not_contains: String
  species_starts_with: String
  species_not_starts_with: String
  species_ends_with: String
  species_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  age: String
  age_not: String
  age_in: [String!]
  age_not_in: [String!]
  age_lt: String
  age_lte: String
  age_gt: String
  age_gte: String
  age_contains: String
  age_not_contains: String
  age_starts_with: String
  age_not_starts_with: String
  age_ends_with: String
  age_not_ends_with: String
  image_every: ImageWhereInput
  image_some: ImageWhereInput
  image_none: ImageWhereInput
  parent: BirdParentWhereInput
  dna: ImageWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BirdWhereInput!]
  OR: [BirdWhereInput!]
  NOT: [BirdWhereInput!]
}

input BirdWhereUniqueInput {
  id: ID
  ring: String
}

type BreedingLog {
  id: ID!
  type: String
  born: String
  dead: String
  timeStamp: String!
  description: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type BreedingLogConnection {
  pageInfo: PageInfo!
  edges: [BreedingLogEdge]!
  aggregate: AggregateBreedingLog!
}

input BreedingLogCreateInput {
  id: ID
  type: String
  born: String
  dead: String
  timeStamp: String!
  description: String!
}

input BreedingLogCreateManyInput {
  create: [BreedingLogCreateInput!]
  connect: [BreedingLogWhereUniqueInput!]
}

type BreedingLogEdge {
  node: BreedingLog!
  cursor: String!
}

enum BreedingLogOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  born_ASC
  born_DESC
  dead_ASC
  dead_DESC
  timeStamp_ASC
  timeStamp_DESC
  description_ASC
  description_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BreedingLogPreviousValues {
  id: ID!
  type: String
  born: String
  dead: String
  timeStamp: String!
  description: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input BreedingLogScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  born: String
  born_not: String
  born_in: [String!]
  born_not_in: [String!]
  born_lt: String
  born_lte: String
  born_gt: String
  born_gte: String
  born_contains: String
  born_not_contains: String
  born_starts_with: String
  born_not_starts_with: String
  born_ends_with: String
  born_not_ends_with: String
  dead: String
  dead_not: String
  dead_in: [String!]
  dead_not_in: [String!]
  dead_lt: String
  dead_lte: String
  dead_gt: String
  dead_gte: String
  dead_contains: String
  dead_not_contains: String
  dead_starts_with: String
  dead_not_starts_with: String
  dead_ends_with: String
  dead_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BreedingLogScalarWhereInput!]
  OR: [BreedingLogScalarWhereInput!]
  NOT: [BreedingLogScalarWhereInput!]
}

type BreedingLogSubscriptionPayload {
  mutation: MutationType!
  node: BreedingLog
  updatedFields: [String!]
  previousValues: BreedingLogPreviousValues
}

input BreedingLogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BreedingLogWhereInput
  AND: [BreedingLogSubscriptionWhereInput!]
  OR: [BreedingLogSubscriptionWhereInput!]
  NOT: [BreedingLogSubscriptionWhereInput!]
}

input BreedingLogUpdateDataInput {
  type: String
  born: String
  dead: String
  timeStamp: String
  description: String
}

input BreedingLogUpdateInput {
  type: String
  born: String
  dead: String
  timeStamp: String
  description: String
}

input BreedingLogUpdateManyDataInput {
  type: String
  born: String
  dead: String
  timeStamp: String
  description: String
}

input BreedingLogUpdateManyInput {
  create: [BreedingLogCreateInput!]
  update: [BreedingLogUpdateWithWhereUniqueNestedInput!]
  upsert: [BreedingLogUpsertWithWhereUniqueNestedInput!]
  delete: [BreedingLogWhereUniqueInput!]
  connect: [BreedingLogWhereUniqueInput!]
  set: [BreedingLogWhereUniqueInput!]
  disconnect: [BreedingLogWhereUniqueInput!]
  deleteMany: [BreedingLogScalarWhereInput!]
  updateMany: [BreedingLogUpdateManyWithWhereNestedInput!]
}

input BreedingLogUpdateManyMutationInput {
  type: String
  born: String
  dead: String
  timeStamp: String
  description: String
}

input BreedingLogUpdateManyWithWhereNestedInput {
  where: BreedingLogScalarWhereInput!
  data: BreedingLogUpdateManyDataInput!
}

input BreedingLogUpdateWithWhereUniqueNestedInput {
  where: BreedingLogWhereUniqueInput!
  data: BreedingLogUpdateDataInput!
}

input BreedingLogUpsertWithWhereUniqueNestedInput {
  where: BreedingLogWhereUniqueInput!
  update: BreedingLogUpdateDataInput!
  create: BreedingLogCreateInput!
}

input BreedingLogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  born: String
  born_not: String
  born_in: [String!]
  born_not_in: [String!]
  born_lt: String
  born_lte: String
  born_gt: String
  born_gte: String
  born_contains: String
  born_not_contains: String
  born_starts_with: String
  born_not_starts_with: String
  born_ends_with: String
  born_not_ends_with: String
  dead: String
  dead_not: String
  dead_in: [String!]
  dead_not_in: [String!]
  dead_lt: String
  dead_lte: String
  dead_gt: String
  dead_gte: String
  dead_contains: String
  dead_not_contains: String
  dead_starts_with: String
  dead_not_starts_with: String
  dead_ends_with: String
  dead_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BreedingLogWhereInput!]
  OR: [BreedingLogWhereInput!]
  NOT: [BreedingLogWhereInput!]
}

input BreedingLogWhereUniqueInput {
  id: ID
}

type BreedingRecord {
  id: ID!
  name: String
  status: String
  parent: BirdParent
  log(where: BreedingLogWhereInput, orderBy: BreedingLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BreedingLog!]
  updatedAt: DateTime!
  createdAt: DateTime!
}

type BreedingRecordConnection {
  pageInfo: PageInfo!
  edges: [BreedingRecordEdge]!
  aggregate: AggregateBreedingRecord!
}

input BreedingRecordCreateInput {
  id: ID
  name: String
  status: String
  parent: BirdParentCreateOneWithoutBreedingRecordInput
  log: BreedingLogCreateManyInput
}

input BreedingRecordCreateManyWithoutParentInput {
  create: [BreedingRecordCreateWithoutParentInput!]
  connect: [BreedingRecordWhereUniqueInput!]
}

input BreedingRecordCreateWithoutParentInput {
  id: ID
  name: String
  status: String
  log: BreedingLogCreateManyInput
}

type BreedingRecordEdge {
  node: BreedingRecord!
  cursor: String!
}

enum BreedingRecordOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  status_ASC
  status_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type BreedingRecordPreviousValues {
  id: ID!
  name: String
  status: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

input BreedingRecordScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BreedingRecordScalarWhereInput!]
  OR: [BreedingRecordScalarWhereInput!]
  NOT: [BreedingRecordScalarWhereInput!]
}

type BreedingRecordSubscriptionPayload {
  mutation: MutationType!
  node: BreedingRecord
  updatedFields: [String!]
  previousValues: BreedingRecordPreviousValues
}

input BreedingRecordSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BreedingRecordWhereInput
  AND: [BreedingRecordSubscriptionWhereInput!]
  OR: [BreedingRecordSubscriptionWhereInput!]
  NOT: [BreedingRecordSubscriptionWhereInput!]
}

input BreedingRecordUpdateInput {
  name: String
  status: String
  parent: BirdParentUpdateOneWithoutBreedingRecordInput
  log: BreedingLogUpdateManyInput
}

input BreedingRecordUpdateManyDataInput {
  name: String
  status: String
}

input BreedingRecordUpdateManyMutationInput {
  name: String
  status: String
}

input BreedingRecordUpdateManyWithoutParentInput {
  create: [BreedingRecordCreateWithoutParentInput!]
  delete: [BreedingRecordWhereUniqueInput!]
  connect: [BreedingRecordWhereUniqueInput!]
  set: [BreedingRecordWhereUniqueInput!]
  disconnect: [BreedingRecordWhereUniqueInput!]
  update: [BreedingRecordUpdateWithWhereUniqueWithoutParentInput!]
  upsert: [BreedingRecordUpsertWithWhereUniqueWithoutParentInput!]
  deleteMany: [BreedingRecordScalarWhereInput!]
  updateMany: [BreedingRecordUpdateManyWithWhereNestedInput!]
}

input BreedingRecordUpdateManyWithWhereNestedInput {
  where: BreedingRecordScalarWhereInput!
  data: BreedingRecordUpdateManyDataInput!
}

input BreedingRecordUpdateWithoutParentDataInput {
  name: String
  status: String
  log: BreedingLogUpdateManyInput
}

input BreedingRecordUpdateWithWhereUniqueWithoutParentInput {
  where: BreedingRecordWhereUniqueInput!
  data: BreedingRecordUpdateWithoutParentDataInput!
}

input BreedingRecordUpsertWithWhereUniqueWithoutParentInput {
  where: BreedingRecordWhereUniqueInput!
  update: BreedingRecordUpdateWithoutParentDataInput!
  create: BreedingRecordCreateWithoutParentInput!
}

input BreedingRecordWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  parent: BirdParentWhereInput
  log_every: BreedingLogWhereInput
  log_some: BreedingLogWhereInput
  log_none: BreedingLogWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BreedingRecordWhereInput!]
  OR: [BreedingRecordWhereInput!]
  NOT: [BreedingRecordWhereInput!]
}

input BreedingRecordWhereUniqueInput {
  id: ID
}

type Comment {
  id: ID!
  user: User!
  auction: Auction!
  message: String!
  timeStamp: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  user: UserCreateOneWithoutCommentsInput!
  auction: AuctionCreateOneWithoutCommentsInput!
  message: String!
  timeStamp: String!
}

input CommentCreateManyWithoutAuctionInput {
  create: [CommentCreateWithoutAuctionInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutUserInput {
  create: [CommentCreateWithoutUserInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAuctionInput {
  id: ID
  user: UserCreateOneWithoutCommentsInput!
  message: String!
  timeStamp: String!
}

input CommentCreateWithoutUserInput {
  id: ID
  auction: AuctionCreateOneWithoutCommentsInput!
  message: String!
  timeStamp: String!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  timeStamp_ASC
  timeStamp_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CommentPreviousValues {
  id: ID!
  message: String!
  timeStamp: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  user: UserUpdateOneRequiredWithoutCommentsInput
  auction: AuctionUpdateOneRequiredWithoutCommentsInput
  message: String
  timeStamp: String
}

input CommentUpdateManyDataInput {
  message: String
  timeStamp: String
}

input CommentUpdateManyMutationInput {
  message: String
  timeStamp: String
}

input CommentUpdateManyWithoutAuctionInput {
  create: [CommentCreateWithoutAuctionInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuctionInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuctionInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutUserInput {
  create: [CommentCreateWithoutUserInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutAuctionDataInput {
  user: UserUpdateOneRequiredWithoutCommentsInput
  message: String
  timeStamp: String
}

input CommentUpdateWithoutUserDataInput {
  auction: AuctionUpdateOneRequiredWithoutCommentsInput
  message: String
  timeStamp: String
}

input CommentUpdateWithWhereUniqueWithoutAuctionInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAuctionDataInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutUserDataInput!
}

input CommentUpsertWithWhereUniqueWithoutAuctionInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAuctionDataInput!
  create: CommentCreateWithoutAuctionInput!
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutUserDataInput!
  create: CommentCreateWithoutUserInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  auction: AuctionWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Image {
  id: ID!
  src: String!
  description: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  src: String!
  description: String!
}

input ImageCreateManyInput {
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

input ImageCreateOneInput {
  create: ImageCreateInput
  connect: ImageWhereUniqueInput
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  src_ASC
  src_DESC
  description_ASC
  description_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type ImagePreviousValues {
  id: ID!
  src: String!
  description: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

input ImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  NOT: [ImageScalarWhereInput!]
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  src: String
  description: String
}

input ImageUpdateInput {
  src: String
  description: String
}

input ImageUpdateManyDataInput {
  src: String
  description: String
}

input ImageUpdateManyInput {
  create: [ImageCreateInput!]
  update: [ImageUpdateWithWhereUniqueNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueNestedInput!]
  delete: [ImageWhereUniqueInput!]
  connect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  disconnect: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
}

input ImageUpdateManyMutationInput {
  src: String
  description: String
}

input ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput!
  data: ImageUpdateManyDataInput!
}

input ImageUpdateOneInput {
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ImageWhereUniqueInput
}

input ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  data: ImageUpdateDataInput!
}

input ImageUpsertNestedInput {
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

type Journal {
  id: ID!
  transaction: Transaction
  balance: String
  timeStamp: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

type JournalConnection {
  pageInfo: PageInfo!
  edges: [JournalEdge]!
  aggregate: AggregateJournal!
}

input JournalCreateInput {
  id: ID
  transaction: TransactionCreateOneInput
  balance: String
  timeStamp: String
}

input JournalCreateOneInput {
  create: JournalCreateInput
  connect: JournalWhereUniqueInput
}

type JournalEdge {
  node: Journal!
  cursor: String!
}

enum JournalOrderByInput {
  id_ASC
  id_DESC
  balance_ASC
  balance_DESC
  timeStamp_ASC
  timeStamp_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type JournalPreviousValues {
  id: ID!
  balance: String
  timeStamp: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

type JournalSubscriptionPayload {
  mutation: MutationType!
  node: Journal
  updatedFields: [String!]
  previousValues: JournalPreviousValues
}

input JournalSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JournalWhereInput
  AND: [JournalSubscriptionWhereInput!]
  OR: [JournalSubscriptionWhereInput!]
  NOT: [JournalSubscriptionWhereInput!]
}

input JournalUpdateDataInput {
  transaction: TransactionUpdateOneInput
  balance: String
  timeStamp: String
}

input JournalUpdateInput {
  transaction: TransactionUpdateOneInput
  balance: String
  timeStamp: String
}

input JournalUpdateManyMutationInput {
  balance: String
  timeStamp: String
}

input JournalUpdateOneInput {
  create: JournalCreateInput
  update: JournalUpdateDataInput
  upsert: JournalUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: JournalWhereUniqueInput
}

input JournalUpsertNestedInput {
  update: JournalUpdateDataInput!
  create: JournalCreateInput!
}

input JournalWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  transaction: TransactionWhereInput
  balance: String
  balance_not: String
  balance_in: [String!]
  balance_not_in: [String!]
  balance_lt: String
  balance_lte: String
  balance_gt: String
  balance_gte: String
  balance_contains: String
  balance_not_contains: String
  balance_starts_with: String
  balance_not_starts_with: String
  balance_ends_with: String
  balance_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [JournalWhereInput!]
  OR: [JournalWhereInput!]
  NOT: [JournalWhereInput!]
}

input JournalWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAuction(data: AuctionCreateInput!): Auction!
  updateAuction(data: AuctionUpdateInput!, where: AuctionWhereUniqueInput!): Auction
  updateManyAuctions(data: AuctionUpdateManyMutationInput!, where: AuctionWhereInput): BatchPayload!
  upsertAuction(where: AuctionWhereUniqueInput!, create: AuctionCreateInput!, update: AuctionUpdateInput!): Auction!
  deleteAuction(where: AuctionWhereUniqueInput!): Auction
  deleteManyAuctions(where: AuctionWhereInput): BatchPayload!
  createAuthPayload(data: AuthPayloadCreateInput!): AuthPayload!
  updateAuthPayload(data: AuthPayloadUpdateInput!, where: AuthPayloadWhereUniqueInput!): AuthPayload
  updateManyAuthPayloads(data: AuthPayloadUpdateManyMutationInput!, where: AuthPayloadWhereInput): BatchPayload!
  upsertAuthPayload(where: AuthPayloadWhereUniqueInput!, create: AuthPayloadCreateInput!, update: AuthPayloadUpdateInput!): AuthPayload!
  deleteAuthPayload(where: AuthPayloadWhereUniqueInput!): AuthPayload
  deleteManyAuthPayloads(where: AuthPayloadWhereInput): BatchPayload!
  createBid(data: BidCreateInput!): Bid!
  updateBid(data: BidUpdateInput!, where: BidWhereUniqueInput!): Bid
  updateManyBids(data: BidUpdateManyMutationInput!, where: BidWhereInput): BatchPayload!
  upsertBid(where: BidWhereUniqueInput!, create: BidCreateInput!, update: BidUpdateInput!): Bid!
  deleteBid(where: BidWhereUniqueInput!): Bid
  deleteManyBids(where: BidWhereInput): BatchPayload!
  createBird(data: BirdCreateInput!): Bird!
  updateBird(data: BirdUpdateInput!, where: BirdWhereUniqueInput!): Bird
  updateManyBirds(data: BirdUpdateManyMutationInput!, where: BirdWhereInput): BatchPayload!
  upsertBird(where: BirdWhereUniqueInput!, create: BirdCreateInput!, update: BirdUpdateInput!): Bird!
  deleteBird(where: BirdWhereUniqueInput!): Bird
  deleteManyBirds(where: BirdWhereInput): BatchPayload!
  createBirdParent(data: BirdParentCreateInput!): BirdParent!
  updateBirdParent(data: BirdParentUpdateInput!, where: BirdParentWhereUniqueInput!): BirdParent
  updateManyBirdParents(data: BirdParentUpdateManyMutationInput!, where: BirdParentWhereInput): BatchPayload!
  upsertBirdParent(where: BirdParentWhereUniqueInput!, create: BirdParentCreateInput!, update: BirdParentUpdateInput!): BirdParent!
  deleteBirdParent(where: BirdParentWhereUniqueInput!): BirdParent
  deleteManyBirdParents(where: BirdParentWhereInput): BatchPayload!
  createBreedingLog(data: BreedingLogCreateInput!): BreedingLog!
  updateBreedingLog(data: BreedingLogUpdateInput!, where: BreedingLogWhereUniqueInput!): BreedingLog
  updateManyBreedingLogs(data: BreedingLogUpdateManyMutationInput!, where: BreedingLogWhereInput): BatchPayload!
  upsertBreedingLog(where: BreedingLogWhereUniqueInput!, create: BreedingLogCreateInput!, update: BreedingLogUpdateInput!): BreedingLog!
  deleteBreedingLog(where: BreedingLogWhereUniqueInput!): BreedingLog
  deleteManyBreedingLogs(where: BreedingLogWhereInput): BatchPayload!
  createBreedingRecord(data: BreedingRecordCreateInput!): BreedingRecord!
  updateBreedingRecord(data: BreedingRecordUpdateInput!, where: BreedingRecordWhereUniqueInput!): BreedingRecord
  updateManyBreedingRecords(data: BreedingRecordUpdateManyMutationInput!, where: BreedingRecordWhereInput): BatchPayload!
  upsertBreedingRecord(where: BreedingRecordWhereUniqueInput!, create: BreedingRecordCreateInput!, update: BreedingRecordUpdateInput!): BreedingRecord!
  deleteBreedingRecord(where: BreedingRecordWhereUniqueInput!): BreedingRecord
  deleteManyBreedingRecords(where: BreedingRecordWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createJournal(data: JournalCreateInput!): Journal!
  updateJournal(data: JournalUpdateInput!, where: JournalWhereUniqueInput!): Journal
  updateManyJournals(data: JournalUpdateManyMutationInput!, where: JournalWhereInput): BatchPayload!
  upsertJournal(where: JournalWhereUniqueInput!, create: JournalCreateInput!, update: JournalUpdateInput!): Journal!
  deleteJournal(where: JournalWhereUniqueInput!): Journal
  deleteManyJournals(where: JournalWhereInput): BatchPayload!
  createTransaction(data: TransactionCreateInput!): Transaction!
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateManyTransactions(data: TransactionUpdateManyMutationInput!, where: TransactionWhereInput): BatchPayload!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteManyTransactions(where: TransactionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  auction(where: AuctionWhereUniqueInput!): Auction
  auctions(where: AuctionWhereInput, orderBy: AuctionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Auction]!
  auctionsConnection(where: AuctionWhereInput, orderBy: AuctionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AuctionConnection!
  authPayload(where: AuthPayloadWhereUniqueInput!): AuthPayload
  authPayloads(where: AuthPayloadWhereInput, orderBy: AuthPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AuthPayload]!
  authPayloadsConnection(where: AuthPayloadWhereInput, orderBy: AuthPayloadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AuthPayloadConnection!
  bid(where: BidWhereUniqueInput!): Bid
  bids(where: BidWhereInput, orderBy: BidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bid]!
  bidsConnection(where: BidWhereInput, orderBy: BidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BidConnection!
  bird(where: BirdWhereUniqueInput!): Bird
  birds(where: BirdWhereInput, orderBy: BirdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bird]!
  birdsConnection(where: BirdWhereInput, orderBy: BirdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BirdConnection!
  birdParent(where: BirdParentWhereUniqueInput!): BirdParent
  birdParents(where: BirdParentWhereInput, orderBy: BirdParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BirdParent]!
  birdParentsConnection(where: BirdParentWhereInput, orderBy: BirdParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BirdParentConnection!
  breedingLog(where: BreedingLogWhereUniqueInput!): BreedingLog
  breedingLogs(where: BreedingLogWhereInput, orderBy: BreedingLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BreedingLog]!
  breedingLogsConnection(where: BreedingLogWhereInput, orderBy: BreedingLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BreedingLogConnection!
  breedingRecord(where: BreedingRecordWhereUniqueInput!): BreedingRecord
  breedingRecords(where: BreedingRecordWhereInput, orderBy: BreedingRecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BreedingRecord]!
  breedingRecordsConnection(where: BreedingRecordWhereInput, orderBy: BreedingRecordOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BreedingRecordConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  journal(where: JournalWhereUniqueInput!): Journal
  journals(where: JournalWhereInput, orderBy: JournalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Journal]!
  journalsConnection(where: JournalWhereInput, orderBy: JournalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JournalConnection!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  auction(where: AuctionSubscriptionWhereInput): AuctionSubscriptionPayload
  authPayload(where: AuthPayloadSubscriptionWhereInput): AuthPayloadSubscriptionPayload
  bid(where: BidSubscriptionWhereInput): BidSubscriptionPayload
  bird(where: BirdSubscriptionWhereInput): BirdSubscriptionPayload
  birdParent(where: BirdParentSubscriptionWhereInput): BirdParentSubscriptionPayload
  breedingLog(where: BreedingLogSubscriptionWhereInput): BreedingLogSubscriptionPayload
  breedingRecord(where: BreedingRecordSubscriptionWhereInput): BreedingRecordSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  journal(where: JournalSubscriptionWhereInput): JournalSubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Transaction {
  id: ID!
  type: String
  decription: String
  amount: String
  timeStamp: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  id: ID
  type: String
  decription: String
  amount: String
  timeStamp: String
}

input TransactionCreateOneInput {
  create: TransactionCreateInput
  connect: TransactionWhereUniqueInput
}

type TransactionEdge {
  node: Transaction!
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  decription_ASC
  decription_DESC
  amount_ASC
  amount_DESC
  timeStamp_ASC
  timeStamp_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TransactionPreviousValues {
  id: ID!
  type: String
  decription: String
  amount: String
  timeStamp: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
  AND: [TransactionSubscriptionWhereInput!]
  OR: [TransactionSubscriptionWhereInput!]
  NOT: [TransactionSubscriptionWhereInput!]
}

input TransactionUpdateDataInput {
  type: String
  decription: String
  amount: String
  timeStamp: String
}

input TransactionUpdateInput {
  type: String
  decription: String
  amount: String
  timeStamp: String
}

input TransactionUpdateManyMutationInput {
  type: String
  decription: String
  amount: String
  timeStamp: String
}

input TransactionUpdateOneInput {
  create: TransactionCreateInput
  update: TransactionUpdateDataInput
  upsert: TransactionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TransactionWhereUniqueInput
}

input TransactionUpsertNestedInput {
  update: TransactionUpdateDataInput!
  create: TransactionCreateInput!
}

input TransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  decription: String
  decription_not: String
  decription_in: [String!]
  decription_not_in: [String!]
  decription_lt: String
  decription_lte: String
  decription_gt: String
  decription_gte: String
  decription_contains: String
  decription_not_contains: String
  decription_starts_with: String
  decription_not_starts_with: String
  decription_ends_with: String
  decription_not_ends_with: String
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  timeStamp: String
  timeStamp_not: String
  timeStamp_in: [String!]
  timeStamp_not_in: [String!]
  timeStamp_lt: String
  timeStamp_lte: String
  timeStamp_gt: String
  timeStamp_gte: String
  timeStamp_contains: String
  timeStamp_not_contains: String
  timeStamp_starts_with: String
  timeStamp_not_starts_with: String
  timeStamp_ends_with: String
  timeStamp_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
}

input TransactionWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: Journal
  birthday: String
  ktp: String
  ktpImage: Image
  gender: String
  image: Image
  auctions(where: AuctionWhereInput, orderBy: AuctionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Auction!]
  bids(where: BidWhereInput, orderBy: BidOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bid!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  birdOwned(where: BirdWhereInput, orderBy: BirdOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bird!]
  birdParent(where: BirdParentWhereInput, orderBy: BirdParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BirdParent!]
  updatedAt: DateTime!
  createdAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalCreateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageCreateOneInput
  gender: String
  image: ImageCreateOneInput
  auctions: AuctionCreateManyWithoutSellerInput
  bids: BidCreateManyWithoutBidderInput
  comments: CommentCreateManyWithoutUserInput
  birdOwned: BirdCreateManyWithoutOwnerInput
  birdParent: BirdParentCreateManyInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAuctionsInput {
  create: UserCreateWithoutAuctionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBidsInput {
  create: UserCreateWithoutBidsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBirdOwnedInput {
  create: UserCreateWithoutBirdOwnedInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAuctionsInput {
  id: ID
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalCreateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageCreateOneInput
  gender: String
  image: ImageCreateOneInput
  bids: BidCreateManyWithoutBidderInput
  comments: CommentCreateManyWithoutUserInput
  birdOwned: BirdCreateManyWithoutOwnerInput
  birdParent: BirdParentCreateManyInput
}

input UserCreateWithoutBidsInput {
  id: ID
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalCreateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageCreateOneInput
  gender: String
  image: ImageCreateOneInput
  auctions: AuctionCreateManyWithoutSellerInput
  comments: CommentCreateManyWithoutUserInput
  birdOwned: BirdCreateManyWithoutOwnerInput
  birdParent: BirdParentCreateManyInput
}

input UserCreateWithoutBirdOwnedInput {
  id: ID
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalCreateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageCreateOneInput
  gender: String
  image: ImageCreateOneInput
  auctions: AuctionCreateManyWithoutSellerInput
  bids: BidCreateManyWithoutBidderInput
  comments: CommentCreateManyWithoutUserInput
  birdParent: BirdParentCreateManyInput
}

input UserCreateWithoutCommentsInput {
  id: ID
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalCreateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageCreateOneInput
  gender: String
  image: ImageCreateOneInput
  auctions: AuctionCreateManyWithoutSellerInput
  bids: BidCreateManyWithoutBidderInput
  birdOwned: BirdCreateManyWithoutOwnerInput
  birdParent: BirdParentCreateManyInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  city_ASC
  city_DESC
  location_ASC
  location_DESC
  address_ASC
  address_DESC
  phone_ASC
  phone_DESC
  birthday_ASC
  birthday_DESC
  ktp_ASC
  ktp_DESC
  gender_ASC
  gender_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String
  city: String
  location: String
  address: String
  phone: String
  birthday: String
  ktp: String
  gender: String
  updatedAt: DateTime!
  createdAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalUpdateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageUpdateOneInput
  gender: String
  image: ImageUpdateOneInput
  auctions: AuctionUpdateManyWithoutSellerInput
  bids: BidUpdateManyWithoutBidderInput
  comments: CommentUpdateManyWithoutUserInput
  birdOwned: BirdUpdateManyWithoutOwnerInput
  birdParent: BirdParentUpdateManyInput
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalUpdateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageUpdateOneInput
  gender: String
  image: ImageUpdateOneInput
  auctions: AuctionUpdateManyWithoutSellerInput
  bids: BidUpdateManyWithoutBidderInput
  comments: CommentUpdateManyWithoutUserInput
  birdOwned: BirdUpdateManyWithoutOwnerInput
  birdParent: BirdParentUpdateManyInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  birthday: String
  ktp: String
  gender: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutAuctionsInput {
  create: UserCreateWithoutAuctionsInput
  update: UserUpdateWithoutAuctionsDataInput
  upsert: UserUpsertWithoutAuctionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBidsInput {
  create: UserCreateWithoutBidsInput
  update: UserUpdateWithoutBidsDataInput
  upsert: UserUpsertWithoutBidsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBirdOwnedInput {
  create: UserCreateWithoutBirdOwnedInput
  update: UserUpdateWithoutBirdOwnedDataInput
  upsert: UserUpsertWithoutBirdOwnedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAuctionsDataInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalUpdateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageUpdateOneInput
  gender: String
  image: ImageUpdateOneInput
  bids: BidUpdateManyWithoutBidderInput
  comments: CommentUpdateManyWithoutUserInput
  birdOwned: BirdUpdateManyWithoutOwnerInput
  birdParent: BirdParentUpdateManyInput
}

input UserUpdateWithoutBidsDataInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalUpdateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageUpdateOneInput
  gender: String
  image: ImageUpdateOneInput
  auctions: AuctionUpdateManyWithoutSellerInput
  comments: CommentUpdateManyWithoutUserInput
  birdOwned: BirdUpdateManyWithoutOwnerInput
  birdParent: BirdParentUpdateManyInput
}

input UserUpdateWithoutBirdOwnedDataInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalUpdateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageUpdateOneInput
  gender: String
  image: ImageUpdateOneInput
  auctions: AuctionUpdateManyWithoutSellerInput
  bids: BidUpdateManyWithoutBidderInput
  comments: CommentUpdateManyWithoutUserInput
  birdParent: BirdParentUpdateManyInput
}

input UserUpdateWithoutCommentsDataInput {
  email: String
  password: String
  name: String
  city: String
  location: String
  address: String
  phone: String
  journal: JournalUpdateOneInput
  birthday: String
  ktp: String
  ktpImage: ImageUpdateOneInput
  gender: String
  image: ImageUpdateOneInput
  auctions: AuctionUpdateManyWithoutSellerInput
  bids: BidUpdateManyWithoutBidderInput
  birdOwned: BirdUpdateManyWithoutOwnerInput
  birdParent: BirdParentUpdateManyInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutAuctionsInput {
  update: UserUpdateWithoutAuctionsDataInput!
  create: UserCreateWithoutAuctionsInput!
}

input UserUpsertWithoutBidsInput {
  update: UserUpdateWithoutBidsDataInput!
  create: UserCreateWithoutBidsInput!
}

input UserUpsertWithoutBirdOwnedInput {
  update: UserUpdateWithoutBirdOwnedDataInput!
  create: UserCreateWithoutBirdOwnedInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  journal: JournalWhereInput
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  ktp: String
  ktp_not: String
  ktp_in: [String!]
  ktp_not_in: [String!]
  ktp_lt: String
  ktp_lte: String
  ktp_gt: String
  ktp_gte: String
  ktp_contains: String
  ktp_not_contains: String
  ktp_starts_with: String
  ktp_not_starts_with: String
  ktp_ends_with: String
  ktp_not_ends_with: String
  ktpImage: ImageWhereInput
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  image: ImageWhereInput
  auctions_every: AuctionWhereInput
  auctions_some: AuctionWhereInput
  auctions_none: AuctionWhereInput
  bids_every: BidWhereInput
  bids_some: BidWhereInput
  bids_none: BidWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  birdOwned_every: BirdWhereInput
  birdOwned_some: BirdWhereInput
  birdOwned_none: BirdWhereInput
  birdParent_every: BirdParentWhereInput
  birdParent_some: BirdParentWhereInput
  birdParent_none: BirdParentWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    