// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  auction: (where?: AuctionWhereInput) => Promise<boolean>;
  authPayload: (where?: AuthPayloadWhereInput) => Promise<boolean>;
  bid: (where?: BidWhereInput) => Promise<boolean>;
  bird: (where?: BirdWhereInput) => Promise<boolean>;
  birdParent: (where?: BirdParentWhereInput) => Promise<boolean>;
  breedingLog: (where?: BreedingLogWhereInput) => Promise<boolean>;
  breedingRecord: (where?: BreedingRecordWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  journal: (where?: JournalWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  auction: (where: AuctionWhereUniqueInput) => AuctionNullablePromise;
  auctions: (args?: {
    where?: AuctionWhereInput;
    orderBy?: AuctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Auction>;
  auctionsConnection: (args?: {
    where?: AuctionWhereInput;
    orderBy?: AuctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuctionConnectionPromise;
  authPayload: (
    where: AuthPayloadWhereUniqueInput
  ) => AuthPayloadNullablePromise;
  authPayloads: (args?: {
    where?: AuthPayloadWhereInput;
    orderBy?: AuthPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AuthPayload>;
  authPayloadsConnection: (args?: {
    where?: AuthPayloadWhereInput;
    orderBy?: AuthPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthPayloadConnectionPromise;
  bid: (where: BidWhereUniqueInput) => BidNullablePromise;
  bids: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bid>;
  bidsConnection: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BidConnectionPromise;
  bird: (where: BirdWhereUniqueInput) => BirdNullablePromise;
  birds: (args?: {
    where?: BirdWhereInput;
    orderBy?: BirdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bird>;
  birdsConnection: (args?: {
    where?: BirdWhereInput;
    orderBy?: BirdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BirdConnectionPromise;
  birdParent: (where: BirdParentWhereUniqueInput) => BirdParentNullablePromise;
  birdParents: (args?: {
    where?: BirdParentWhereInput;
    orderBy?: BirdParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BirdParent>;
  birdParentsConnection: (args?: {
    where?: BirdParentWhereInput;
    orderBy?: BirdParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BirdParentConnectionPromise;
  breedingLog: (
    where: BreedingLogWhereUniqueInput
  ) => BreedingLogNullablePromise;
  breedingLogs: (args?: {
    where?: BreedingLogWhereInput;
    orderBy?: BreedingLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BreedingLog>;
  breedingLogsConnection: (args?: {
    where?: BreedingLogWhereInput;
    orderBy?: BreedingLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BreedingLogConnectionPromise;
  breedingRecord: (
    where: BreedingRecordWhereUniqueInput
  ) => BreedingRecordNullablePromise;
  breedingRecords: (args?: {
    where?: BreedingRecordWhereInput;
    orderBy?: BreedingRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BreedingRecord>;
  breedingRecordsConnection: (args?: {
    where?: BreedingRecordWhereInput;
    orderBy?: BreedingRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BreedingRecordConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  journal: (where: JournalWhereUniqueInput) => JournalNullablePromise;
  journals: (args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Journal>;
  journalsConnection: (args?: {
    where?: JournalWhereInput;
    orderBy?: JournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JournalConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuction: (data: AuctionCreateInput) => AuctionPromise;
  updateAuction: (args: {
    data: AuctionUpdateInput;
    where: AuctionWhereUniqueInput;
  }) => AuctionPromise;
  updateManyAuctions: (args: {
    data: AuctionUpdateManyMutationInput;
    where?: AuctionWhereInput;
  }) => BatchPayloadPromise;
  upsertAuction: (args: {
    where: AuctionWhereUniqueInput;
    create: AuctionCreateInput;
    update: AuctionUpdateInput;
  }) => AuctionPromise;
  deleteAuction: (where: AuctionWhereUniqueInput) => AuctionPromise;
  deleteManyAuctions: (where?: AuctionWhereInput) => BatchPayloadPromise;
  createAuthPayload: (data: AuthPayloadCreateInput) => AuthPayloadPromise;
  updateAuthPayload: (args: {
    data: AuthPayloadUpdateInput;
    where: AuthPayloadWhereUniqueInput;
  }) => AuthPayloadPromise;
  updateManyAuthPayloads: (args: {
    data: AuthPayloadUpdateManyMutationInput;
    where?: AuthPayloadWhereInput;
  }) => BatchPayloadPromise;
  upsertAuthPayload: (args: {
    where: AuthPayloadWhereUniqueInput;
    create: AuthPayloadCreateInput;
    update: AuthPayloadUpdateInput;
  }) => AuthPayloadPromise;
  deleteAuthPayload: (where: AuthPayloadWhereUniqueInput) => AuthPayloadPromise;
  deleteManyAuthPayloads: (
    where?: AuthPayloadWhereInput
  ) => BatchPayloadPromise;
  createBid: (data: BidCreateInput) => BidPromise;
  updateBid: (args: {
    data: BidUpdateInput;
    where: BidWhereUniqueInput;
  }) => BidPromise;
  updateManyBids: (args: {
    data: BidUpdateManyMutationInput;
    where?: BidWhereInput;
  }) => BatchPayloadPromise;
  upsertBid: (args: {
    where: BidWhereUniqueInput;
    create: BidCreateInput;
    update: BidUpdateInput;
  }) => BidPromise;
  deleteBid: (where: BidWhereUniqueInput) => BidPromise;
  deleteManyBids: (where?: BidWhereInput) => BatchPayloadPromise;
  createBird: (data: BirdCreateInput) => BirdPromise;
  updateBird: (args: {
    data: BirdUpdateInput;
    where: BirdWhereUniqueInput;
  }) => BirdPromise;
  updateManyBirds: (args: {
    data: BirdUpdateManyMutationInput;
    where?: BirdWhereInput;
  }) => BatchPayloadPromise;
  upsertBird: (args: {
    where: BirdWhereUniqueInput;
    create: BirdCreateInput;
    update: BirdUpdateInput;
  }) => BirdPromise;
  deleteBird: (where: BirdWhereUniqueInput) => BirdPromise;
  deleteManyBirds: (where?: BirdWhereInput) => BatchPayloadPromise;
  createBirdParent: (data: BirdParentCreateInput) => BirdParentPromise;
  updateBirdParent: (args: {
    data: BirdParentUpdateInput;
    where: BirdParentWhereUniqueInput;
  }) => BirdParentPromise;
  updateManyBirdParents: (args: {
    data: BirdParentUpdateManyMutationInput;
    where?: BirdParentWhereInput;
  }) => BatchPayloadPromise;
  upsertBirdParent: (args: {
    where: BirdParentWhereUniqueInput;
    create: BirdParentCreateInput;
    update: BirdParentUpdateInput;
  }) => BirdParentPromise;
  deleteBirdParent: (where: BirdParentWhereUniqueInput) => BirdParentPromise;
  deleteManyBirdParents: (where?: BirdParentWhereInput) => BatchPayloadPromise;
  createBreedingLog: (data: BreedingLogCreateInput) => BreedingLogPromise;
  updateBreedingLog: (args: {
    data: BreedingLogUpdateInput;
    where: BreedingLogWhereUniqueInput;
  }) => BreedingLogPromise;
  updateManyBreedingLogs: (args: {
    data: BreedingLogUpdateManyMutationInput;
    where?: BreedingLogWhereInput;
  }) => BatchPayloadPromise;
  upsertBreedingLog: (args: {
    where: BreedingLogWhereUniqueInput;
    create: BreedingLogCreateInput;
    update: BreedingLogUpdateInput;
  }) => BreedingLogPromise;
  deleteBreedingLog: (where: BreedingLogWhereUniqueInput) => BreedingLogPromise;
  deleteManyBreedingLogs: (
    where?: BreedingLogWhereInput
  ) => BatchPayloadPromise;
  createBreedingRecord: (
    data: BreedingRecordCreateInput
  ) => BreedingRecordPromise;
  updateBreedingRecord: (args: {
    data: BreedingRecordUpdateInput;
    where: BreedingRecordWhereUniqueInput;
  }) => BreedingRecordPromise;
  updateManyBreedingRecords: (args: {
    data: BreedingRecordUpdateManyMutationInput;
    where?: BreedingRecordWhereInput;
  }) => BatchPayloadPromise;
  upsertBreedingRecord: (args: {
    where: BreedingRecordWhereUniqueInput;
    create: BreedingRecordCreateInput;
    update: BreedingRecordUpdateInput;
  }) => BreedingRecordPromise;
  deleteBreedingRecord: (
    where: BreedingRecordWhereUniqueInput
  ) => BreedingRecordPromise;
  deleteManyBreedingRecords: (
    where?: BreedingRecordWhereInput
  ) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createJournal: (data: JournalCreateInput) => JournalPromise;
  updateJournal: (args: {
    data: JournalUpdateInput;
    where: JournalWhereUniqueInput;
  }) => JournalPromise;
  updateManyJournals: (args: {
    data: JournalUpdateManyMutationInput;
    where?: JournalWhereInput;
  }) => BatchPayloadPromise;
  upsertJournal: (args: {
    where: JournalWhereUniqueInput;
    create: JournalCreateInput;
    update: JournalUpdateInput;
  }) => JournalPromise;
  deleteJournal: (where: JournalWhereUniqueInput) => JournalPromise;
  deleteManyJournals: (where?: JournalWhereInput) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  auction: (
    where?: AuctionSubscriptionWhereInput
  ) => AuctionSubscriptionPayloadSubscription;
  authPayload: (
    where?: AuthPayloadSubscriptionWhereInput
  ) => AuthPayloadSubscriptionPayloadSubscription;
  bid: (
    where?: BidSubscriptionWhereInput
  ) => BidSubscriptionPayloadSubscription;
  bird: (
    where?: BirdSubscriptionWhereInput
  ) => BirdSubscriptionPayloadSubscription;
  birdParent: (
    where?: BirdParentSubscriptionWhereInput
  ) => BirdParentSubscriptionPayloadSubscription;
  breedingLog: (
    where?: BreedingLogSubscriptionWhereInput
  ) => BreedingLogSubscriptionPayloadSubscription;
  breedingRecord: (
    where?: BreedingRecordSubscriptionWhereInput
  ) => BreedingRecordSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  journal: (
    where?: JournalSubscriptionWhereInput
  ) => JournalSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BreedingLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "born_ASC"
  | "born_DESC"
  | "dead_ASC"
  | "dead_DESC"
  | "timeStamp_ASC"
  | "timeStamp_DESC"
  | "description_ASC"
  | "description_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AuctionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "openPrice_ASC"
  | "openPrice_DESC"
  | "closePrice_ASC"
  | "closePrice_DESC"
  | "incrementAmount_ASC"
  | "incrementAmount_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "closeTime_ASC"
  | "closeTime_DESC"
  | "isClosed_ASC"
  | "isClosed_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type BreedingRecordOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "status_ASC"
  | "status_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "city_ASC"
  | "city_DESC"
  | "location_ASC"
  | "location_DESC"
  | "address_ASC"
  | "address_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "ktp_ASC"
  | "ktp_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type BidOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amountBid_ASC"
  | "amountBid_DESC"
  | "timeStamp_ASC"
  | "timeStamp_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "timeStamp_ASC"
  | "timeStamp_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type BirdOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "ring_ASC"
  | "ring_DESC"
  | "breeder_ASC"
  | "breeder_DESC"
  | "species_ASC"
  | "species_DESC"
  | "type_ASC"
  | "type_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "age_ASC"
  | "age_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type BirdParentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "noParent_ASC"
  | "noParent_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "decription_ASC"
  | "decription_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "timeStamp_ASC"
  | "timeStamp_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "src_ASC"
  | "src_DESC"
  | "description_ASC"
  | "description_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AuthPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "token_ASC"
  | "token_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type JournalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "timeStamp_ASC"
  | "timeStamp_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export interface AuctionUpdateOneRequiredInput {
  create?: Maybe<AuctionCreateInput>;
  update?: Maybe<AuctionUpdateDataInput>;
  upsert?: Maybe<AuctionUpsertNestedInput>;
  connect?: Maybe<AuctionWhereUniqueInput>;
}

export type AuctionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BidScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amountBid?: Maybe<String>;
  amountBid_not?: Maybe<String>;
  amountBid_in?: Maybe<String[] | String>;
  amountBid_not_in?: Maybe<String[] | String>;
  amountBid_lt?: Maybe<String>;
  amountBid_lte?: Maybe<String>;
  amountBid_gt?: Maybe<String>;
  amountBid_gte?: Maybe<String>;
  amountBid_contains?: Maybe<String>;
  amountBid_not_contains?: Maybe<String>;
  amountBid_starts_with?: Maybe<String>;
  amountBid_not_starts_with?: Maybe<String>;
  amountBid_ends_with?: Maybe<String>;
  amountBid_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  OR?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  NOT?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface BidUpdateManyWithWhereNestedInput {
  where: BidScalarWhereInput;
  data: BidUpdateManyDataInput;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  auction?: Maybe<AuctionWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface BidUpdateManyDataInput {
  amountBid?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface BreedingRecordWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  parent?: Maybe<BirdParentWhereInput>;
  log_every?: Maybe<BreedingLogWhereInput>;
  log_some?: Maybe<BreedingLogWhereInput>;
  log_none?: Maybe<BreedingLogWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BreedingRecordWhereInput[] | BreedingRecordWhereInput>;
  OR?: Maybe<BreedingRecordWhereInput[] | BreedingRecordWhereInput>;
  NOT?: Maybe<BreedingRecordWhereInput[] | BreedingRecordWhereInput>;
}

export interface BreedingLogCreateManyInput {
  create?: Maybe<BreedingLogCreateInput[] | BreedingLogCreateInput>;
  connect?: Maybe<BreedingLogWhereUniqueInput[] | BreedingLogWhereUniqueInput>;
}

export interface AuctionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  openPrice?: Maybe<String>;
  openPrice_not?: Maybe<String>;
  openPrice_in?: Maybe<String[] | String>;
  openPrice_not_in?: Maybe<String[] | String>;
  openPrice_lt?: Maybe<String>;
  openPrice_lte?: Maybe<String>;
  openPrice_gt?: Maybe<String>;
  openPrice_gte?: Maybe<String>;
  openPrice_contains?: Maybe<String>;
  openPrice_not_contains?: Maybe<String>;
  openPrice_starts_with?: Maybe<String>;
  openPrice_not_starts_with?: Maybe<String>;
  openPrice_ends_with?: Maybe<String>;
  openPrice_not_ends_with?: Maybe<String>;
  closePrice?: Maybe<String>;
  closePrice_not?: Maybe<String>;
  closePrice_in?: Maybe<String[] | String>;
  closePrice_not_in?: Maybe<String[] | String>;
  closePrice_lt?: Maybe<String>;
  closePrice_lte?: Maybe<String>;
  closePrice_gt?: Maybe<String>;
  closePrice_gte?: Maybe<String>;
  closePrice_contains?: Maybe<String>;
  closePrice_not_contains?: Maybe<String>;
  closePrice_starts_with?: Maybe<String>;
  closePrice_not_starts_with?: Maybe<String>;
  closePrice_ends_with?: Maybe<String>;
  closePrice_not_ends_with?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  incrementAmount_not?: Maybe<String>;
  incrementAmount_in?: Maybe<String[] | String>;
  incrementAmount_not_in?: Maybe<String[] | String>;
  incrementAmount_lt?: Maybe<String>;
  incrementAmount_lte?: Maybe<String>;
  incrementAmount_gt?: Maybe<String>;
  incrementAmount_gte?: Maybe<String>;
  incrementAmount_contains?: Maybe<String>;
  incrementAmount_not_contains?: Maybe<String>;
  incrementAmount_starts_with?: Maybe<String>;
  incrementAmount_not_starts_with?: Maybe<String>;
  incrementAmount_ends_with?: Maybe<String>;
  incrementAmount_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  closeTime?: Maybe<String>;
  closeTime_not?: Maybe<String>;
  closeTime_in?: Maybe<String[] | String>;
  closeTime_not_in?: Maybe<String[] | String>;
  closeTime_lt?: Maybe<String>;
  closeTime_lte?: Maybe<String>;
  closeTime_gt?: Maybe<String>;
  closeTime_gte?: Maybe<String>;
  closeTime_contains?: Maybe<String>;
  closeTime_not_contains?: Maybe<String>;
  closeTime_starts_with?: Maybe<String>;
  closeTime_not_starts_with?: Maybe<String>;
  closeTime_ends_with?: Maybe<String>;
  closeTime_not_ends_with?: Maybe<String>;
  isClosed?: Maybe<Boolean>;
  isClosed_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AuctionScalarWhereInput[] | AuctionScalarWhereInput>;
  OR?: Maybe<AuctionScalarWhereInput[] | AuctionScalarWhereInput>;
  NOT?: Maybe<AuctionScalarWhereInput[] | AuctionScalarWhereInput>;
}

export interface BreedingLogCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<String>;
  born?: Maybe<String>;
  dead?: Maybe<String>;
  timeStamp: String;
  description: String;
}

export interface CommentUpdateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutUserInput[]
    | CommentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutUserInput[]
    | CommentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface BirdParentCreateManyInput {
  create?: Maybe<BirdParentCreateInput[] | BirdParentCreateInput>;
  connect?: Maybe<BirdParentWhereUniqueInput[] | BirdParentWhereUniqueInput>;
}

export interface JournalWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  transaction?: Maybe<TransactionWhereInput>;
  balance?: Maybe<String>;
  balance_not?: Maybe<String>;
  balance_in?: Maybe<String[] | String>;
  balance_not_in?: Maybe<String[] | String>;
  balance_lt?: Maybe<String>;
  balance_lte?: Maybe<String>;
  balance_gt?: Maybe<String>;
  balance_gte?: Maybe<String>;
  balance_contains?: Maybe<String>;
  balance_not_contains?: Maybe<String>;
  balance_starts_with?: Maybe<String>;
  balance_not_starts_with?: Maybe<String>;
  balance_ends_with?: Maybe<String>;
  balance_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<JournalWhereInput[] | JournalWhereInput>;
  OR?: Maybe<JournalWhereInput[] | JournalWhereInput>;
  NOT?: Maybe<JournalWhereInput[] | JournalWhereInput>;
}

export interface BidCreateOneInput {
  create?: Maybe<BidCreateInput>;
  connect?: Maybe<BidWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  journal?: Maybe<JournalWhereInput>;
  birthday?: Maybe<String>;
  birthday_not?: Maybe<String>;
  birthday_in?: Maybe<String[] | String>;
  birthday_not_in?: Maybe<String[] | String>;
  birthday_lt?: Maybe<String>;
  birthday_lte?: Maybe<String>;
  birthday_gt?: Maybe<String>;
  birthday_gte?: Maybe<String>;
  birthday_contains?: Maybe<String>;
  birthday_not_contains?: Maybe<String>;
  birthday_starts_with?: Maybe<String>;
  birthday_not_starts_with?: Maybe<String>;
  birthday_ends_with?: Maybe<String>;
  birthday_not_ends_with?: Maybe<String>;
  ktp?: Maybe<String>;
  ktp_not?: Maybe<String>;
  ktp_in?: Maybe<String[] | String>;
  ktp_not_in?: Maybe<String[] | String>;
  ktp_lt?: Maybe<String>;
  ktp_lte?: Maybe<String>;
  ktp_gt?: Maybe<String>;
  ktp_gte?: Maybe<String>;
  ktp_contains?: Maybe<String>;
  ktp_not_contains?: Maybe<String>;
  ktp_starts_with?: Maybe<String>;
  ktp_not_starts_with?: Maybe<String>;
  ktp_ends_with?: Maybe<String>;
  ktp_not_ends_with?: Maybe<String>;
  ktpImage?: Maybe<ImageWhereInput>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  image?: Maybe<ImageWhereInput>;
  auctions_every?: Maybe<AuctionWhereInput>;
  auctions_some?: Maybe<AuctionWhereInput>;
  auctions_none?: Maybe<AuctionWhereInput>;
  bids_every?: Maybe<BidWhereInput>;
  bids_some?: Maybe<BidWhereInput>;
  bids_none?: Maybe<BidWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  birdOwned_every?: Maybe<BirdWhereInput>;
  birdOwned_some?: Maybe<BirdWhereInput>;
  birdOwned_none?: Maybe<BirdWhereInput>;
  birdParent_every?: Maybe<BirdParentWhereInput>;
  birdParent_some?: Maybe<BirdParentWhereInput>;
  birdParent_none?: Maybe<BirdParentWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CommentCreateManyWithoutAuctionInput {
  create?: Maybe<
    CommentCreateWithoutAuctionInput[] | CommentCreateWithoutAuctionInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface BirdWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ring?: Maybe<String>;
  ring_not?: Maybe<String>;
  ring_in?: Maybe<String[] | String>;
  ring_not_in?: Maybe<String[] | String>;
  ring_lt?: Maybe<String>;
  ring_lte?: Maybe<String>;
  ring_gt?: Maybe<String>;
  ring_gte?: Maybe<String>;
  ring_contains?: Maybe<String>;
  ring_not_contains?: Maybe<String>;
  ring_starts_with?: Maybe<String>;
  ring_not_starts_with?: Maybe<String>;
  ring_ends_with?: Maybe<String>;
  ring_not_ends_with?: Maybe<String>;
  owner?: Maybe<UserWhereInput>;
  breeder?: Maybe<String>;
  breeder_not?: Maybe<String>;
  breeder_in?: Maybe<String[] | String>;
  breeder_not_in?: Maybe<String[] | String>;
  breeder_lt?: Maybe<String>;
  breeder_lte?: Maybe<String>;
  breeder_gt?: Maybe<String>;
  breeder_gte?: Maybe<String>;
  breeder_contains?: Maybe<String>;
  breeder_not_contains?: Maybe<String>;
  breeder_starts_with?: Maybe<String>;
  breeder_not_starts_with?: Maybe<String>;
  breeder_ends_with?: Maybe<String>;
  breeder_not_ends_with?: Maybe<String>;
  species?: Maybe<String>;
  species_not?: Maybe<String>;
  species_in?: Maybe<String[] | String>;
  species_not_in?: Maybe<String[] | String>;
  species_lt?: Maybe<String>;
  species_lte?: Maybe<String>;
  species_gt?: Maybe<String>;
  species_gte?: Maybe<String>;
  species_contains?: Maybe<String>;
  species_not_contains?: Maybe<String>;
  species_starts_with?: Maybe<String>;
  species_not_starts_with?: Maybe<String>;
  species_ends_with?: Maybe<String>;
  species_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  age?: Maybe<String>;
  age_not?: Maybe<String>;
  age_in?: Maybe<String[] | String>;
  age_not_in?: Maybe<String[] | String>;
  age_lt?: Maybe<String>;
  age_lte?: Maybe<String>;
  age_gt?: Maybe<String>;
  age_gte?: Maybe<String>;
  age_contains?: Maybe<String>;
  age_not_contains?: Maybe<String>;
  age_starts_with?: Maybe<String>;
  age_not_starts_with?: Maybe<String>;
  age_ends_with?: Maybe<String>;
  age_not_ends_with?: Maybe<String>;
  image_every?: Maybe<ImageWhereInput>;
  image_some?: Maybe<ImageWhereInput>;
  image_none?: Maybe<ImageWhereInput>;
  parent?: Maybe<BirdParentWhereInput>;
  dna?: Maybe<ImageWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BirdWhereInput[] | BirdWhereInput>;
  OR?: Maybe<BirdWhereInput[] | BirdWhereInput>;
  NOT?: Maybe<BirdWhereInput[] | BirdWhereInput>;
}

export interface CommentCreateWithoutAuctionInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutCommentsInput;
  message: String;
  timeStamp: String;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BreedingRecordSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BreedingRecordWhereInput>;
  AND?: Maybe<
    | BreedingRecordSubscriptionWhereInput[]
    | BreedingRecordSubscriptionWhereInput
  >;
  OR?: Maybe<
    | BreedingRecordSubscriptionWhereInput[]
    | BreedingRecordSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | BreedingRecordSubscriptionWhereInput[]
    | BreedingRecordSubscriptionWhereInput
  >;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalCreateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageCreateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageCreateOneInput>;
  auctions?: Maybe<AuctionCreateManyWithoutSellerInput>;
  bids?: Maybe<BidCreateManyWithoutBidderInput>;
  birdOwned?: Maybe<BirdCreateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentCreateManyInput>;
}

export interface BirdParentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BirdParentWhereInput>;
  AND?: Maybe<
    BirdParentSubscriptionWhereInput[] | BirdParentSubscriptionWhereInput
  >;
  OR?: Maybe<
    BirdParentSubscriptionWhereInput[] | BirdParentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BirdParentSubscriptionWhereInput[] | BirdParentSubscriptionWhereInput
  >;
}

export interface AuctionUpdateInput {
  bird?: Maybe<BirdUpdateOneRequiredInput>;
  seller?: Maybe<UserUpdateOneRequiredWithoutAuctionsInput>;
  openPrice?: Maybe<String>;
  closePrice?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  startTime?: Maybe<String>;
  closeTime?: Maybe<String>;
  bids?: Maybe<BidUpdateManyInput>;
  lastBid?: Maybe<BidUpdateOneInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuctionInput>;
  isClosed?: Maybe<Boolean>;
}

export interface BidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BidWhereInput>;
  AND?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  OR?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  NOT?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
}

export interface BirdUpdateOneRequiredInput {
  create?: Maybe<BirdCreateInput>;
  update?: Maybe<BirdUpdateDataInput>;
  upsert?: Maybe<BirdUpsertNestedInput>;
  connect?: Maybe<BirdWhereUniqueInput>;
}

export interface AuctionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuctionWhereInput>;
  AND?: Maybe<AuctionSubscriptionWhereInput[] | AuctionSubscriptionWhereInput>;
  OR?: Maybe<AuctionSubscriptionWhereInput[] | AuctionSubscriptionWhereInput>;
  NOT?: Maybe<AuctionSubscriptionWhereInput[] | AuctionSubscriptionWhereInput>;
}

export interface BirdUpdateDataInput {
  name?: Maybe<String>;
  ring?: Maybe<String>;
  owner?: Maybe<UserUpdateOneRequiredWithoutBirdOwnedInput>;
  breeder?: Maybe<String>;
  species?: Maybe<String>;
  type?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  image?: Maybe<ImageUpdateManyInput>;
  parent?: Maybe<BirdParentUpdateOneInput>;
  dna?: Maybe<ImageUpdateOneInput>;
}

export type AuthPayloadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutBirdOwnedInput {
  create?: Maybe<UserCreateWithoutBirdOwnedInput>;
  update?: Maybe<UserUpdateWithoutBirdOwnedDataInput>;
  upsert?: Maybe<UserUpsertWithoutBirdOwnedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AuthPayloadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AuthPayloadWhereInput[] | AuthPayloadWhereInput>;
  OR?: Maybe<AuthPayloadWhereInput[] | AuthPayloadWhereInput>;
  NOT?: Maybe<AuthPayloadWhereInput[] | AuthPayloadWhereInput>;
}

export interface UserUpdateWithoutBirdOwnedDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalUpdateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageUpdateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  auctions?: Maybe<AuctionUpdateManyWithoutSellerInput>;
  bids?: Maybe<BidUpdateManyWithoutBidderInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  birdParent?: Maybe<BirdParentUpdateManyInput>;
}

export interface TransactionUpdateInput {
  type?: Maybe<String>;
  decription?: Maybe<String>;
  amount?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface JournalUpdateOneInput {
  create?: Maybe<JournalCreateInput>;
  update?: Maybe<JournalUpdateDataInput>;
  upsert?: Maybe<JournalUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<JournalWhereUniqueInput>;
}

export interface JournalUpdateInput {
  transaction?: Maybe<TransactionUpdateOneInput>;
  balance?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface JournalUpdateDataInput {
  transaction?: Maybe<TransactionUpdateOneInput>;
  balance?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface ImageUpdateManyMutationInput {
  src?: Maybe<String>;
  description?: Maybe<String>;
}

export interface TransactionUpdateOneInput {
  create?: Maybe<TransactionCreateInput>;
  update?: Maybe<TransactionUpdateDataInput>;
  upsert?: Maybe<TransactionUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface CommentUpdateManyMutationInput {
  message?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface TransactionUpdateDataInput {
  type?: Maybe<String>;
  decription?: Maybe<String>;
  amount?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface CommentUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  auction?: Maybe<AuctionUpdateOneRequiredWithoutCommentsInput>;
  message?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface TransactionUpsertNestedInput {
  update: TransactionUpdateDataInput;
  create: TransactionCreateInput;
}

export interface BreedingRecordUpdateManyMutationInput {
  name?: Maybe<String>;
  status?: Maybe<String>;
}

export interface JournalUpsertNestedInput {
  update: JournalUpdateDataInput;
  create: JournalCreateInput;
}

export interface BirdParentUpsertWithoutBreedingRecordInput {
  update: BirdParentUpdateWithoutBreedingRecordDataInput;
  create: BirdParentCreateWithoutBreedingRecordInput;
}

export interface ImageUpdateOneInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface BirdParentUpdateOneWithoutBreedingRecordInput {
  create?: Maybe<BirdParentCreateWithoutBreedingRecordInput>;
  update?: Maybe<BirdParentUpdateWithoutBreedingRecordDataInput>;
  upsert?: Maybe<BirdParentUpsertWithoutBreedingRecordInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BirdParentWhereUniqueInput>;
}

export interface ImageUpdateDataInput {
  src?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BreedingRecordUpdateInput {
  name?: Maybe<String>;
  status?: Maybe<String>;
  parent?: Maybe<BirdParentUpdateOneWithoutBreedingRecordInput>;
  log?: Maybe<BreedingLogUpdateManyInput>;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface BirdParentCreateOneWithoutBreedingRecordInput {
  create?: Maybe<BirdParentCreateWithoutBreedingRecordInput>;
  connect?: Maybe<BirdParentWhereUniqueInput>;
}

export interface AuctionUpdateManyWithoutSellerInput {
  create?: Maybe<
    AuctionCreateWithoutSellerInput[] | AuctionCreateWithoutSellerInput
  >;
  delete?: Maybe<AuctionWhereUniqueInput[] | AuctionWhereUniqueInput>;
  connect?: Maybe<AuctionWhereUniqueInput[] | AuctionWhereUniqueInput>;
  set?: Maybe<AuctionWhereUniqueInput[] | AuctionWhereUniqueInput>;
  disconnect?: Maybe<AuctionWhereUniqueInput[] | AuctionWhereUniqueInput>;
  update?: Maybe<
    | AuctionUpdateWithWhereUniqueWithoutSellerInput[]
    | AuctionUpdateWithWhereUniqueWithoutSellerInput
  >;
  upsert?: Maybe<
    | AuctionUpsertWithWhereUniqueWithoutSellerInput[]
    | AuctionUpsertWithWhereUniqueWithoutSellerInput
  >;
  deleteMany?: Maybe<AuctionScalarWhereInput[] | AuctionScalarWhereInput>;
  updateMany?: Maybe<
    | AuctionUpdateManyWithWhereNestedInput[]
    | AuctionUpdateManyWithWhereNestedInput
  >;
}

export interface BreedingRecordCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  status?: Maybe<String>;
  parent?: Maybe<BirdParentCreateOneWithoutBreedingRecordInput>;
  log?: Maybe<BreedingLogCreateManyInput>;
}

export interface AuctionUpdateWithWhereUniqueWithoutSellerInput {
  where: AuctionWhereUniqueInput;
  data: AuctionUpdateWithoutSellerDataInput;
}

export interface BreedingLogUpdateInput {
  type?: Maybe<String>;
  born?: Maybe<String>;
  dead?: Maybe<String>;
  timeStamp?: Maybe<String>;
  description?: Maybe<String>;
}

export interface AuctionUpdateWithoutSellerDataInput {
  bird?: Maybe<BirdUpdateOneRequiredInput>;
  openPrice?: Maybe<String>;
  closePrice?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  startTime?: Maybe<String>;
  closeTime?: Maybe<String>;
  bids?: Maybe<BidUpdateManyInput>;
  lastBid?: Maybe<BidUpdateOneInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuctionInput>;
  isClosed?: Maybe<Boolean>;
}

export interface BirdParentUpdateManyMutationInput {
  noParent?: Maybe<String>;
}

export interface BidUpdateManyInput {
  create?: Maybe<BidCreateInput[] | BidCreateInput>;
  update?: Maybe<
    BidUpdateWithWhereUniqueNestedInput[] | BidUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    BidUpsertWithWhereUniqueNestedInput[] | BidUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  set?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  disconnect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  deleteMany?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  updateMany?: Maybe<
    BidUpdateManyWithWhereNestedInput[] | BidUpdateManyWithWhereNestedInput
  >;
}

export interface BirdUpdateManyMutationInput {
  name?: Maybe<String>;
  ring?: Maybe<String>;
  breeder?: Maybe<String>;
  species?: Maybe<String>;
  type?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
}

export interface BidUpdateWithWhereUniqueNestedInput {
  where: BidWhereUniqueInput;
  data: BidUpdateDataInput;
}

export interface BirdUpdateInput {
  name?: Maybe<String>;
  ring?: Maybe<String>;
  owner?: Maybe<UserUpdateOneRequiredWithoutBirdOwnedInput>;
  breeder?: Maybe<String>;
  species?: Maybe<String>;
  type?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  image?: Maybe<ImageUpdateManyInput>;
  parent?: Maybe<BirdParentUpdateOneInput>;
  dna?: Maybe<ImageUpdateOneInput>;
}

export interface BidUpdateDataInput {
  auction?: Maybe<AuctionUpdateOneRequiredInput>;
  bidder?: Maybe<UserUpdateOneRequiredWithoutBidsInput>;
  amountBid?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface BidUpdateInput {
  auction?: Maybe<AuctionUpdateOneRequiredInput>;
  bidder?: Maybe<UserUpdateOneRequiredWithoutBidsInput>;
  amountBid?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface AuctionUpdateManyWithWhereNestedInput {
  where: AuctionScalarWhereInput;
  data: AuctionUpdateManyDataInput;
}

export interface AuthPayloadUpdateManyMutationInput {
  token?: Maybe<String>;
}

export interface AuctionUpdateDataInput {
  bird?: Maybe<BirdUpdateOneRequiredInput>;
  seller?: Maybe<UserUpdateOneRequiredWithoutAuctionsInput>;
  openPrice?: Maybe<String>;
  closePrice?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  startTime?: Maybe<String>;
  closeTime?: Maybe<String>;
  bids?: Maybe<BidUpdateManyInput>;
  lastBid?: Maybe<BidUpdateOneInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuctionInput>;
  isClosed?: Maybe<Boolean>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalUpdateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageUpdateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  auctions?: Maybe<AuctionUpdateManyWithoutSellerInput>;
  bids?: Maybe<BidUpdateManyWithoutBidderInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdUpdateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentUpdateManyInput>;
}

export interface UserUpdateOneRequiredWithoutAuctionsInput {
  create?: Maybe<UserCreateWithoutAuctionsInput>;
  update?: Maybe<UserUpdateWithoutAuctionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutAuctionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithoutAuctionsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalUpdateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageUpdateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  bids?: Maybe<BidUpdateManyWithoutBidderInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdUpdateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentUpdateManyInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalCreateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageCreateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageCreateOneInput>;
  auctions?: Maybe<AuctionCreateManyWithoutSellerInput>;
  bids?: Maybe<BidCreateManyWithoutBidderInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdCreateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentCreateManyInput>;
}

export interface BidUpdateManyWithoutBidderInput {
  create?: Maybe<BidCreateWithoutBidderInput[] | BidCreateWithoutBidderInput>;
  delete?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  set?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  disconnect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  update?: Maybe<
    | BidUpdateWithWhereUniqueWithoutBidderInput[]
    | BidUpdateWithWhereUniqueWithoutBidderInput
  >;
  upsert?: Maybe<
    | BidUpsertWithWhereUniqueWithoutBidderInput[]
    | BidUpsertWithWhereUniqueWithoutBidderInput
  >;
  deleteMany?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  updateMany?: Maybe<
    BidUpdateManyWithWhereNestedInput[] | BidUpdateManyWithWhereNestedInput
  >;
}

export interface AuthPayloadCreateInput {
  id?: Maybe<ID_Input>;
  token?: Maybe<String>;
  user?: Maybe<UserCreateOneInput>;
}

export interface BidUpdateWithWhereUniqueWithoutBidderInput {
  where: BidWhereUniqueInput;
  data: BidUpdateWithoutBidderDataInput;
}

export interface AuctionUpdateManyMutationInput {
  openPrice?: Maybe<String>;
  closePrice?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  startTime?: Maybe<String>;
  closeTime?: Maybe<String>;
  isClosed?: Maybe<Boolean>;
}

export interface BidUpdateWithoutBidderDataInput {
  auction?: Maybe<AuctionUpdateOneRequiredInput>;
  amountBid?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface UserUpsertWithoutBirdOwnedInput {
  update: UserUpdateWithoutBirdOwnedDataInput;
  create: UserCreateWithoutBirdOwnedInput;
}

export interface BidUpsertWithWhereUniqueWithoutBidderInput {
  where: BidWhereUniqueInput;
  update: BidUpdateWithoutBidderDataInput;
  create: BidCreateWithoutBidderInput;
}

export interface BirdCreateOneInput {
  create?: Maybe<BirdCreateInput>;
  connect?: Maybe<BirdWhereUniqueInput>;
}

export interface BidWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  auction?: Maybe<AuctionWhereInput>;
  bidder?: Maybe<UserWhereInput>;
  amountBid?: Maybe<String>;
  amountBid_not?: Maybe<String>;
  amountBid_in?: Maybe<String[] | String>;
  amountBid_not_in?: Maybe<String[] | String>;
  amountBid_lt?: Maybe<String>;
  amountBid_lte?: Maybe<String>;
  amountBid_gt?: Maybe<String>;
  amountBid_gte?: Maybe<String>;
  amountBid_contains?: Maybe<String>;
  amountBid_not_contains?: Maybe<String>;
  amountBid_starts_with?: Maybe<String>;
  amountBid_not_starts_with?: Maybe<String>;
  amountBid_ends_with?: Maybe<String>;
  amountBid_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BidWhereInput[] | BidWhereInput>;
  OR?: Maybe<BidWhereInput[] | BidWhereInput>;
  NOT?: Maybe<BidWhereInput[] | BidWhereInput>;
}

export interface UserCreateOneWithoutBirdOwnedInput {
  create?: Maybe<UserCreateWithoutBirdOwnedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BirdParentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  noParent?: Maybe<String>;
  noParent_not?: Maybe<String>;
  noParent_in?: Maybe<String[] | String>;
  noParent_not_in?: Maybe<String[] | String>;
  noParent_lt?: Maybe<String>;
  noParent_lte?: Maybe<String>;
  noParent_gt?: Maybe<String>;
  noParent_gte?: Maybe<String>;
  noParent_contains?: Maybe<String>;
  noParent_not_contains?: Maybe<String>;
  noParent_starts_with?: Maybe<String>;
  noParent_not_starts_with?: Maybe<String>;
  noParent_ends_with?: Maybe<String>;
  noParent_not_ends_with?: Maybe<String>;
  breedingRecord_every?: Maybe<BreedingRecordWhereInput>;
  breedingRecord_some?: Maybe<BreedingRecordWhereInput>;
  breedingRecord_none?: Maybe<BreedingRecordWhereInput>;
  male?: Maybe<BirdWhereInput>;
  female?: Maybe<BirdWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BirdParentWhereInput[] | BirdParentWhereInput>;
  OR?: Maybe<BirdParentWhereInput[] | BirdParentWhereInput>;
  NOT?: Maybe<BirdParentWhereInput[] | BirdParentWhereInput>;
}

export interface JournalCreateOneInput {
  create?: Maybe<JournalCreateInput>;
  connect?: Maybe<JournalWhereUniqueInput>;
}

export interface BreedingLogWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  born?: Maybe<String>;
  born_not?: Maybe<String>;
  born_in?: Maybe<String[] | String>;
  born_not_in?: Maybe<String[] | String>;
  born_lt?: Maybe<String>;
  born_lte?: Maybe<String>;
  born_gt?: Maybe<String>;
  born_gte?: Maybe<String>;
  born_contains?: Maybe<String>;
  born_not_contains?: Maybe<String>;
  born_starts_with?: Maybe<String>;
  born_not_starts_with?: Maybe<String>;
  born_ends_with?: Maybe<String>;
  born_not_ends_with?: Maybe<String>;
  dead?: Maybe<String>;
  dead_not?: Maybe<String>;
  dead_in?: Maybe<String[] | String>;
  dead_not_in?: Maybe<String[] | String>;
  dead_lt?: Maybe<String>;
  dead_lte?: Maybe<String>;
  dead_gt?: Maybe<String>;
  dead_gte?: Maybe<String>;
  dead_contains?: Maybe<String>;
  dead_not_contains?: Maybe<String>;
  dead_starts_with?: Maybe<String>;
  dead_not_starts_with?: Maybe<String>;
  dead_ends_with?: Maybe<String>;
  dead_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BreedingLogWhereInput[] | BreedingLogWhereInput>;
  OR?: Maybe<BreedingLogWhereInput[] | BreedingLogWhereInput>;
  NOT?: Maybe<BreedingLogWhereInput[] | BreedingLogWhereInput>;
}

export interface TransactionCreateOneInput {
  create?: Maybe<TransactionCreateInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  decription?: Maybe<String>;
  decription_not?: Maybe<String>;
  decription_in?: Maybe<String[] | String>;
  decription_not_in?: Maybe<String[] | String>;
  decription_lt?: Maybe<String>;
  decription_lte?: Maybe<String>;
  decription_gt?: Maybe<String>;
  decription_gte?: Maybe<String>;
  decription_contains?: Maybe<String>;
  decription_not_contains?: Maybe<String>;
  decription_starts_with?: Maybe<String>;
  decription_not_starts_with?: Maybe<String>;
  decription_ends_with?: Maybe<String>;
  decription_not_ends_with?: Maybe<String>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutUserDataInput;
}

export interface AuctionCreateManyWithoutSellerInput {
  create?: Maybe<
    AuctionCreateWithoutSellerInput[] | AuctionCreateWithoutSellerInput
  >;
  connect?: Maybe<AuctionWhereUniqueInput[] | AuctionWhereUniqueInput>;
}

export interface CommentUpdateWithoutUserDataInput {
  auction?: Maybe<AuctionUpdateOneRequiredWithoutCommentsInput>;
  message?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface BidCreateManyInput {
  create?: Maybe<BidCreateInput[] | BidCreateInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
}

export interface AuctionUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<AuctionCreateWithoutCommentsInput>;
  update?: Maybe<AuctionUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<AuctionUpsertWithoutCommentsInput>;
  connect?: Maybe<AuctionWhereUniqueInput>;
}

export interface AuctionCreateOneInput {
  create?: Maybe<AuctionCreateInput>;
  connect?: Maybe<AuctionWhereUniqueInput>;
}

export interface AuctionUpdateWithoutCommentsDataInput {
  bird?: Maybe<BirdUpdateOneRequiredInput>;
  seller?: Maybe<UserUpdateOneRequiredWithoutAuctionsInput>;
  openPrice?: Maybe<String>;
  closePrice?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  startTime?: Maybe<String>;
  closeTime?: Maybe<String>;
  bids?: Maybe<BidUpdateManyInput>;
  lastBid?: Maybe<BidUpdateOneInput>;
  isClosed?: Maybe<Boolean>;
}

export interface UserCreateWithoutBidsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalCreateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageCreateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageCreateOneInput>;
  auctions?: Maybe<AuctionCreateManyWithoutSellerInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdCreateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentCreateManyInput>;
}

export interface BidUpdateOneInput {
  create?: Maybe<BidCreateInput>;
  update?: Maybe<BidUpdateDataInput>;
  upsert?: Maybe<BidUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BidWhereUniqueInput>;
}

export interface CommentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  auction: AuctionCreateOneWithoutCommentsInput;
  message: String;
  timeStamp: String;
}

export interface BidUpsertNestedInput {
  update: BidUpdateDataInput;
  create: BidCreateInput;
}

export interface AuctionCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  bird: BirdCreateOneInput;
  seller: UserCreateOneWithoutAuctionsInput;
  openPrice: String;
  closePrice: String;
  incrementAmount: String;
  startTime: String;
  closeTime: String;
  bids?: Maybe<BidCreateManyInput>;
  lastBid?: Maybe<BidCreateOneInput>;
  isClosed?: Maybe<Boolean>;
}

export interface AuctionUpsertWithoutCommentsInput {
  update: AuctionUpdateWithoutCommentsDataInput;
  create: AuctionCreateWithoutCommentsInput;
}

export interface UserCreateWithoutAuctionsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalCreateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageCreateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageCreateOneInput>;
  bids?: Maybe<BidCreateManyWithoutBidderInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdCreateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentCreateManyInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutUserDataInput;
  create: CommentCreateWithoutUserInput;
}

export interface BidCreateWithoutBidderInput {
  id?: Maybe<ID_Input>;
  auction: AuctionCreateOneInput;
  amountBid: String;
  timeStamp: String;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface BirdCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  ring: String;
  breeder: String;
  species: String;
  type: String;
  gender: String;
  age: String;
  image?: Maybe<ImageCreateManyInput>;
  parent?: Maybe<BirdParentCreateOneInput>;
  dna?: Maybe<ImageCreateOneInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface BirdParentCreateOneInput {
  create?: Maybe<BirdParentCreateInput>;
  connect?: Maybe<BirdParentWhereUniqueInput>;
}

export interface CommentUpdateManyDataInput {
  message?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface BreedingRecordCreateManyWithoutParentInput {
  create?: Maybe<
    | BreedingRecordCreateWithoutParentInput[]
    | BreedingRecordCreateWithoutParentInput
  >;
  connect?: Maybe<
    BreedingRecordWhereUniqueInput[] | BreedingRecordWhereUniqueInput
  >;
}

export interface BirdUpdateManyWithoutOwnerInput {
  create?: Maybe<BirdCreateWithoutOwnerInput[] | BirdCreateWithoutOwnerInput>;
  delete?: Maybe<BirdWhereUniqueInput[] | BirdWhereUniqueInput>;
  connect?: Maybe<BirdWhereUniqueInput[] | BirdWhereUniqueInput>;
  set?: Maybe<BirdWhereUniqueInput[] | BirdWhereUniqueInput>;
  disconnect?: Maybe<BirdWhereUniqueInput[] | BirdWhereUniqueInput>;
  update?: Maybe<
    | BirdUpdateWithWhereUniqueWithoutOwnerInput[]
    | BirdUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | BirdUpsertWithWhereUniqueWithoutOwnerInput[]
    | BirdUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<BirdScalarWhereInput[] | BirdScalarWhereInput>;
  updateMany?: Maybe<
    BirdUpdateManyWithWhereNestedInput[] | BirdUpdateManyWithWhereNestedInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface BirdUpdateWithWhereUniqueWithoutOwnerInput {
  where: BirdWhereUniqueInput;
  data: BirdUpdateWithoutOwnerDataInput;
}

export interface JournalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<JournalWhereInput>;
  AND?: Maybe<JournalSubscriptionWhereInput[] | JournalSubscriptionWhereInput>;
  OR?: Maybe<JournalSubscriptionWhereInput[] | JournalSubscriptionWhereInput>;
  NOT?: Maybe<JournalSubscriptionWhereInput[] | JournalSubscriptionWhereInput>;
}

export interface BirdUpdateWithoutOwnerDataInput {
  name?: Maybe<String>;
  ring?: Maybe<String>;
  breeder?: Maybe<String>;
  species?: Maybe<String>;
  type?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  image?: Maybe<ImageUpdateManyInput>;
  parent?: Maybe<BirdParentUpdateOneInput>;
  dna?: Maybe<ImageUpdateOneInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface ImageUpdateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  update?: Maybe<
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  set?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  disconnect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  deleteMany?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  updateMany?: Maybe<
    ImageUpdateManyWithWhereNestedInput[] | ImageUpdateManyWithWhereNestedInput
  >;
}

export interface BirdSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BirdWhereInput>;
  AND?: Maybe<BirdSubscriptionWhereInput[] | BirdSubscriptionWhereInput>;
  OR?: Maybe<BirdSubscriptionWhereInput[] | BirdSubscriptionWhereInput>;
  NOT?: Maybe<BirdSubscriptionWhereInput[] | BirdSubscriptionWhereInput>;
}

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  gender?: Maybe<String>;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface TransactionUpdateManyMutationInput {
  type?: Maybe<String>;
  decription?: Maybe<String>;
  amount?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface ImageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  OR?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  NOT?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
}

export type BidWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export type BirdWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  ring?: Maybe<String>;
}>;

export interface ImageUpdateManyDataInput {
  src?: Maybe<String>;
  description?: Maybe<String>;
}

export type BirdParentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BirdParentUpdateOneInput {
  create?: Maybe<BirdParentCreateInput>;
  update?: Maybe<BirdParentUpdateDataInput>;
  upsert?: Maybe<BirdParentUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BirdParentWhereUniqueInput>;
}

export type BreedingLogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BirdParentUpdateDataInput {
  noParent?: Maybe<String>;
  breedingRecord?: Maybe<BreedingRecordUpdateManyWithoutParentInput>;
  male?: Maybe<BirdUpdateOneRequiredInput>;
  female?: Maybe<BirdUpdateOneRequiredInput>;
}

export type BreedingRecordWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BreedingRecordUpdateManyWithoutParentInput {
  create?: Maybe<
    | BreedingRecordCreateWithoutParentInput[]
    | BreedingRecordCreateWithoutParentInput
  >;
  delete?: Maybe<
    BreedingRecordWhereUniqueInput[] | BreedingRecordWhereUniqueInput
  >;
  connect?: Maybe<
    BreedingRecordWhereUniqueInput[] | BreedingRecordWhereUniqueInput
  >;
  set?: Maybe<
    BreedingRecordWhereUniqueInput[] | BreedingRecordWhereUniqueInput
  >;
  disconnect?: Maybe<
    BreedingRecordWhereUniqueInput[] | BreedingRecordWhereUniqueInput
  >;
  update?: Maybe<
    | BreedingRecordUpdateWithWhereUniqueWithoutParentInput[]
    | BreedingRecordUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | BreedingRecordUpsertWithWhereUniqueWithoutParentInput[]
    | BreedingRecordUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<
    BreedingRecordScalarWhereInput[] | BreedingRecordScalarWhereInput
  >;
  updateMany?: Maybe<
    | BreedingRecordUpdateManyWithWhereNestedInput[]
    | BreedingRecordUpdateManyWithWhereNestedInput
  >;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BreedingRecordUpdateWithWhereUniqueWithoutParentInput {
  where: BreedingRecordWhereUniqueInput;
  data: BreedingRecordUpdateWithoutParentDataInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BreedingRecordUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  status?: Maybe<String>;
  log?: Maybe<BreedingLogUpdateManyInput>;
}

export type JournalWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BreedingLogUpdateManyInput {
  create?: Maybe<BreedingLogCreateInput[] | BreedingLogCreateInput>;
  update?: Maybe<
    | BreedingLogUpdateWithWhereUniqueNestedInput[]
    | BreedingLogUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BreedingLogUpsertWithWhereUniqueNestedInput[]
    | BreedingLogUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BreedingLogWhereUniqueInput[] | BreedingLogWhereUniqueInput>;
  connect?: Maybe<BreedingLogWhereUniqueInput[] | BreedingLogWhereUniqueInput>;
  set?: Maybe<BreedingLogWhereUniqueInput[] | BreedingLogWhereUniqueInput>;
  disconnect?: Maybe<
    BreedingLogWhereUniqueInput[] | BreedingLogWhereUniqueInput
  >;
  deleteMany?: Maybe<
    BreedingLogScalarWhereInput[] | BreedingLogScalarWhereInput
  >;
  updateMany?: Maybe<
    | BreedingLogUpdateManyWithWhereNestedInput[]
    | BreedingLogUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BreedingLogUpdateWithWhereUniqueNestedInput {
  where: BreedingLogWhereUniqueInput;
  data: BreedingLogUpdateDataInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BreedingLogUpdateDataInput {
  type?: Maybe<String>;
  born?: Maybe<String>;
  dead?: Maybe<String>;
  timeStamp?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BirdUpsertNestedInput {
  update: BirdUpdateDataInput;
  create: BirdCreateInput;
}

export interface BreedingLogUpsertWithWhereUniqueNestedInput {
  where: BreedingLogWhereUniqueInput;
  update: BreedingLogUpdateDataInput;
  create: BreedingLogCreateInput;
}

export interface AuctionCreateInput {
  id?: Maybe<ID_Input>;
  bird: BirdCreateOneInput;
  seller: UserCreateOneWithoutAuctionsInput;
  openPrice: String;
  closePrice: String;
  incrementAmount: String;
  startTime: String;
  closeTime: String;
  bids?: Maybe<BidCreateManyInput>;
  lastBid?: Maybe<BidCreateOneInput>;
  comments?: Maybe<CommentCreateManyWithoutAuctionInput>;
  isClosed?: Maybe<Boolean>;
}

export interface BreedingLogScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  born?: Maybe<String>;
  born_not?: Maybe<String>;
  born_in?: Maybe<String[] | String>;
  born_not_in?: Maybe<String[] | String>;
  born_lt?: Maybe<String>;
  born_lte?: Maybe<String>;
  born_gt?: Maybe<String>;
  born_gte?: Maybe<String>;
  born_contains?: Maybe<String>;
  born_not_contains?: Maybe<String>;
  born_starts_with?: Maybe<String>;
  born_not_starts_with?: Maybe<String>;
  born_ends_with?: Maybe<String>;
  born_not_ends_with?: Maybe<String>;
  dead?: Maybe<String>;
  dead_not?: Maybe<String>;
  dead_in?: Maybe<String[] | String>;
  dead_not_in?: Maybe<String[] | String>;
  dead_lt?: Maybe<String>;
  dead_lte?: Maybe<String>;
  dead_gt?: Maybe<String>;
  dead_gte?: Maybe<String>;
  dead_contains?: Maybe<String>;
  dead_not_contains?: Maybe<String>;
  dead_starts_with?: Maybe<String>;
  dead_not_starts_with?: Maybe<String>;
  dead_ends_with?: Maybe<String>;
  dead_not_ends_with?: Maybe<String>;
  timeStamp?: Maybe<String>;
  timeStamp_not?: Maybe<String>;
  timeStamp_in?: Maybe<String[] | String>;
  timeStamp_not_in?: Maybe<String[] | String>;
  timeStamp_lt?: Maybe<String>;
  timeStamp_lte?: Maybe<String>;
  timeStamp_gt?: Maybe<String>;
  timeStamp_gte?: Maybe<String>;
  timeStamp_contains?: Maybe<String>;
  timeStamp_not_contains?: Maybe<String>;
  timeStamp_starts_with?: Maybe<String>;
  timeStamp_not_starts_with?: Maybe<String>;
  timeStamp_ends_with?: Maybe<String>;
  timeStamp_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BreedingLogScalarWhereInput[] | BreedingLogScalarWhereInput>;
  OR?: Maybe<BreedingLogScalarWhereInput[] | BreedingLogScalarWhereInput>;
  NOT?: Maybe<BreedingLogScalarWhereInput[] | BreedingLogScalarWhereInput>;
}

export interface UserCreateWithoutBirdOwnedInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalCreateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageCreateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageCreateOneInput>;
  auctions?: Maybe<AuctionCreateManyWithoutSellerInput>;
  bids?: Maybe<BidCreateManyWithoutBidderInput>;
  comments?: Maybe<CommentCreateManyWithoutUserInput>;
  birdParent?: Maybe<BirdParentCreateManyInput>;
}

export interface BreedingLogUpdateManyWithWhereNestedInput {
  where: BreedingLogScalarWhereInput;
  data: BreedingLogUpdateManyDataInput;
}

export interface TransactionCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<String>;
  decription?: Maybe<String>;
  amount?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface BreedingLogUpdateManyDataInput {
  type?: Maybe<String>;
  born?: Maybe<String>;
  dead?: Maybe<String>;
  timeStamp?: Maybe<String>;
  description?: Maybe<String>;
}

export interface AuctionCreateWithoutSellerInput {
  id?: Maybe<ID_Input>;
  bird: BirdCreateOneInput;
  openPrice: String;
  closePrice: String;
  incrementAmount: String;
  startTime: String;
  closeTime: String;
  bids?: Maybe<BidCreateManyInput>;
  lastBid?: Maybe<BidCreateOneInput>;
  comments?: Maybe<CommentCreateManyWithoutAuctionInput>;
  isClosed?: Maybe<Boolean>;
}

export interface BreedingRecordUpsertWithWhereUniqueWithoutParentInput {
  where: BreedingRecordWhereUniqueInput;
  update: BreedingRecordUpdateWithoutParentDataInput;
  create: BreedingRecordCreateWithoutParentInput;
}

export interface UserCreateOneWithoutBidsInput {
  create?: Maybe<UserCreateWithoutBidsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BreedingRecordScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    BreedingRecordScalarWhereInput[] | BreedingRecordScalarWhereInput
  >;
  OR?: Maybe<BreedingRecordScalarWhereInput[] | BreedingRecordScalarWhereInput>;
  NOT?: Maybe<
    BreedingRecordScalarWhereInput[] | BreedingRecordScalarWhereInput
  >;
}

export interface AuctionCreateOneWithoutCommentsInput {
  create?: Maybe<AuctionCreateWithoutCommentsInput>;
  connect?: Maybe<AuctionWhereUniqueInput>;
}

export interface BreedingRecordUpdateManyWithWhereNestedInput {
  where: BreedingRecordScalarWhereInput;
  data: BreedingRecordUpdateManyDataInput;
}

export interface BidCreateManyWithoutBidderInput {
  create?: Maybe<BidCreateWithoutBidderInput[] | BidCreateWithoutBidderInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
}

export interface BreedingRecordUpdateManyDataInput {
  name?: Maybe<String>;
  status?: Maybe<String>;
}

export interface ImageCreateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
}

export interface BirdParentUpsertNestedInput {
  update: BirdParentUpdateDataInput;
  create: BirdParentCreateInput;
}

export interface BreedingRecordCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  status?: Maybe<String>;
  log?: Maybe<BreedingLogCreateManyInput>;
}

export interface BirdUpsertWithWhereUniqueWithoutOwnerInput {
  where: BirdWhereUniqueInput;
  update: BirdUpdateWithoutOwnerDataInput;
  create: BirdCreateWithoutOwnerInput;
}

export interface AuctionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  bird?: Maybe<BirdWhereInput>;
  seller?: Maybe<UserWhereInput>;
  openPrice?: Maybe<String>;
  openPrice_not?: Maybe<String>;
  openPrice_in?: Maybe<String[] | String>;
  openPrice_not_in?: Maybe<String[] | String>;
  openPrice_lt?: Maybe<String>;
  openPrice_lte?: Maybe<String>;
  openPrice_gt?: Maybe<String>;
  openPrice_gte?: Maybe<String>;
  openPrice_contains?: Maybe<String>;
  openPrice_not_contains?: Maybe<String>;
  openPrice_starts_with?: Maybe<String>;
  openPrice_not_starts_with?: Maybe<String>;
  openPrice_ends_with?: Maybe<String>;
  openPrice_not_ends_with?: Maybe<String>;
  closePrice?: Maybe<String>;
  closePrice_not?: Maybe<String>;
  closePrice_in?: Maybe<String[] | String>;
  closePrice_not_in?: Maybe<String[] | String>;
  closePrice_lt?: Maybe<String>;
  closePrice_lte?: Maybe<String>;
  closePrice_gt?: Maybe<String>;
  closePrice_gte?: Maybe<String>;
  closePrice_contains?: Maybe<String>;
  closePrice_not_contains?: Maybe<String>;
  closePrice_starts_with?: Maybe<String>;
  closePrice_not_starts_with?: Maybe<String>;
  closePrice_ends_with?: Maybe<String>;
  closePrice_not_ends_with?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  incrementAmount_not?: Maybe<String>;
  incrementAmount_in?: Maybe<String[] | String>;
  incrementAmount_not_in?: Maybe<String[] | String>;
  incrementAmount_lt?: Maybe<String>;
  incrementAmount_lte?: Maybe<String>;
  incrementAmount_gt?: Maybe<String>;
  incrementAmount_gte?: Maybe<String>;
  incrementAmount_contains?: Maybe<String>;
  incrementAmount_not_contains?: Maybe<String>;
  incrementAmount_starts_with?: Maybe<String>;
  incrementAmount_not_starts_with?: Maybe<String>;
  incrementAmount_ends_with?: Maybe<String>;
  incrementAmount_not_ends_with?: Maybe<String>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  closeTime?: Maybe<String>;
  closeTime_not?: Maybe<String>;
  closeTime_in?: Maybe<String[] | String>;
  closeTime_not_in?: Maybe<String[] | String>;
  closeTime_lt?: Maybe<String>;
  closeTime_lte?: Maybe<String>;
  closeTime_gt?: Maybe<String>;
  closeTime_gte?: Maybe<String>;
  closeTime_contains?: Maybe<String>;
  closeTime_not_contains?: Maybe<String>;
  closeTime_starts_with?: Maybe<String>;
  closeTime_not_starts_with?: Maybe<String>;
  closeTime_ends_with?: Maybe<String>;
  closeTime_not_ends_with?: Maybe<String>;
  bids_every?: Maybe<BidWhereInput>;
  bids_some?: Maybe<BidWhereInput>;
  bids_none?: Maybe<BidWhereInput>;
  lastBid?: Maybe<BidWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  isClosed?: Maybe<Boolean>;
  isClosed_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AuctionWhereInput[] | AuctionWhereInput>;
  OR?: Maybe<AuctionWhereInput[] | AuctionWhereInput>;
  NOT?: Maybe<AuctionWhereInput[] | AuctionWhereInput>;
}

export interface BirdScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  ring?: Maybe<String>;
  ring_not?: Maybe<String>;
  ring_in?: Maybe<String[] | String>;
  ring_not_in?: Maybe<String[] | String>;
  ring_lt?: Maybe<String>;
  ring_lte?: Maybe<String>;
  ring_gt?: Maybe<String>;
  ring_gte?: Maybe<String>;
  ring_contains?: Maybe<String>;
  ring_not_contains?: Maybe<String>;
  ring_starts_with?: Maybe<String>;
  ring_not_starts_with?: Maybe<String>;
  ring_ends_with?: Maybe<String>;
  ring_not_ends_with?: Maybe<String>;
  breeder?: Maybe<String>;
  breeder_not?: Maybe<String>;
  breeder_in?: Maybe<String[] | String>;
  breeder_not_in?: Maybe<String[] | String>;
  breeder_lt?: Maybe<String>;
  breeder_lte?: Maybe<String>;
  breeder_gt?: Maybe<String>;
  breeder_gte?: Maybe<String>;
  breeder_contains?: Maybe<String>;
  breeder_not_contains?: Maybe<String>;
  breeder_starts_with?: Maybe<String>;
  breeder_not_starts_with?: Maybe<String>;
  breeder_ends_with?: Maybe<String>;
  breeder_not_ends_with?: Maybe<String>;
  species?: Maybe<String>;
  species_not?: Maybe<String>;
  species_in?: Maybe<String[] | String>;
  species_not_in?: Maybe<String[] | String>;
  species_lt?: Maybe<String>;
  species_lte?: Maybe<String>;
  species_gt?: Maybe<String>;
  species_gte?: Maybe<String>;
  species_contains?: Maybe<String>;
  species_not_contains?: Maybe<String>;
  species_starts_with?: Maybe<String>;
  species_not_starts_with?: Maybe<String>;
  species_ends_with?: Maybe<String>;
  species_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  age?: Maybe<String>;
  age_not?: Maybe<String>;
  age_in?: Maybe<String[] | String>;
  age_not_in?: Maybe<String[] | String>;
  age_lt?: Maybe<String>;
  age_lte?: Maybe<String>;
  age_gt?: Maybe<String>;
  age_gte?: Maybe<String>;
  age_contains?: Maybe<String>;
  age_not_contains?: Maybe<String>;
  age_starts_with?: Maybe<String>;
  age_not_starts_with?: Maybe<String>;
  age_ends_with?: Maybe<String>;
  age_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BirdScalarWhereInput[] | BirdScalarWhereInput>;
  OR?: Maybe<BirdScalarWhereInput[] | BirdScalarWhereInput>;
  NOT?: Maybe<BirdScalarWhereInput[] | BirdScalarWhereInput>;
}

export interface AuthPayloadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthPayloadWhereInput>;
  AND?: Maybe<
    AuthPayloadSubscriptionWhereInput[] | AuthPayloadSubscriptionWhereInput
  >;
  OR?: Maybe<
    AuthPayloadSubscriptionWhereInput[] | AuthPayloadSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AuthPayloadSubscriptionWhereInput[] | AuthPayloadSubscriptionWhereInput
  >;
}

export interface BirdUpdateManyWithWhereNestedInput {
  where: BirdScalarWhereInput;
  data: BirdUpdateManyDataInput;
}

export interface JournalUpdateManyMutationInput {
  balance?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface BirdUpdateManyDataInput {
  name?: Maybe<String>;
  ring?: Maybe<String>;
  breeder?: Maybe<String>;
  species?: Maybe<String>;
  type?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutCommentsInput;
  auction: AuctionCreateOneWithoutCommentsInput;
  message: String;
  timeStamp: String;
}

export interface BirdParentUpdateManyInput {
  create?: Maybe<BirdParentCreateInput[] | BirdParentCreateInput>;
  update?: Maybe<
    | BirdParentUpdateWithWhereUniqueNestedInput[]
    | BirdParentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BirdParentUpsertWithWhereUniqueNestedInput[]
    | BirdParentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BirdParentWhereUniqueInput[] | BirdParentWhereUniqueInput>;
  connect?: Maybe<BirdParentWhereUniqueInput[] | BirdParentWhereUniqueInput>;
  set?: Maybe<BirdParentWhereUniqueInput[] | BirdParentWhereUniqueInput>;
  disconnect?: Maybe<BirdParentWhereUniqueInput[] | BirdParentWhereUniqueInput>;
  deleteMany?: Maybe<BirdParentScalarWhereInput[] | BirdParentScalarWhereInput>;
  updateMany?: Maybe<
    | BirdParentUpdateManyWithWhereNestedInput[]
    | BirdParentUpdateManyWithWhereNestedInput
  >;
}

export interface BirdParentCreateWithoutBreedingRecordInput {
  id?: Maybe<ID_Input>;
  noParent: String;
  male: BirdCreateOneInput;
  female: BirdCreateOneInput;
}

export interface BirdParentUpdateWithWhereUniqueNestedInput {
  where: BirdParentWhereUniqueInput;
  data: BirdParentUpdateDataInput;
}

export interface BirdParentUpdateInput {
  noParent?: Maybe<String>;
  breedingRecord?: Maybe<BreedingRecordUpdateManyWithoutParentInput>;
  male?: Maybe<BirdUpdateOneRequiredInput>;
  female?: Maybe<BirdUpdateOneRequiredInput>;
}

export interface BirdParentUpsertWithWhereUniqueNestedInput {
  where: BirdParentWhereUniqueInput;
  update: BirdParentUpdateDataInput;
  create: BirdParentCreateInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface BirdParentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  noParent?: Maybe<String>;
  noParent_not?: Maybe<String>;
  noParent_in?: Maybe<String[] | String>;
  noParent_not_in?: Maybe<String[] | String>;
  noParent_lt?: Maybe<String>;
  noParent_lte?: Maybe<String>;
  noParent_gt?: Maybe<String>;
  noParent_gte?: Maybe<String>;
  noParent_contains?: Maybe<String>;
  noParent_not_contains?: Maybe<String>;
  noParent_starts_with?: Maybe<String>;
  noParent_not_starts_with?: Maybe<String>;
  noParent_ends_with?: Maybe<String>;
  noParent_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BirdParentScalarWhereInput[] | BirdParentScalarWhereInput>;
  OR?: Maybe<BirdParentScalarWhereInput[] | BirdParentScalarWhereInput>;
  NOT?: Maybe<BirdParentScalarWhereInput[] | BirdParentScalarWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface BirdParentUpdateManyWithWhereNestedInput {
  where: BirdParentScalarWhereInput;
  data: BirdParentUpdateManyDataInput;
}

export interface BirdCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  ring: String;
  owner: UserCreateOneWithoutBirdOwnedInput;
  breeder: String;
  species: String;
  type: String;
  gender: String;
  age: String;
  image?: Maybe<ImageCreateManyInput>;
  parent?: Maybe<BirdParentCreateOneInput>;
  dna?: Maybe<ImageCreateOneInput>;
}

export interface BirdParentUpdateManyDataInput {
  noParent?: Maybe<String>;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  src: String;
  description: String;
}

export interface UserUpsertWithoutAuctionsInput {
  update: UserUpdateWithoutAuctionsDataInput;
  create: UserCreateWithoutAuctionsInput;
}

export interface CommentCreateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentUpdateManyWithoutAuctionInput {
  create?: Maybe<
    CommentCreateWithoutAuctionInput[] | CommentCreateWithoutAuctionInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutAuctionInput[]
    | CommentUpdateWithWhereUniqueWithoutAuctionInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutAuctionInput[]
    | CommentUpsertWithWhereUniqueWithoutAuctionInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface BirdCreateManyWithoutOwnerInput {
  create?: Maybe<BirdCreateWithoutOwnerInput[] | BirdCreateWithoutOwnerInput>;
  connect?: Maybe<BirdWhereUniqueInput[] | BirdWhereUniqueInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutAuctionInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuctionDataInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface CommentUpdateWithoutAuctionDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  message?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalUpdateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageUpdateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  auctions?: Maybe<AuctionUpdateManyWithoutSellerInput>;
  bids?: Maybe<BidUpdateManyWithoutBidderInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdUpdateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentUpdateManyInput>;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BirdParentUpdateWithoutBreedingRecordDataInput {
  noParent?: Maybe<String>;
  male?: Maybe<BirdUpdateOneRequiredInput>;
  female?: Maybe<BirdUpdateOneRequiredInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalUpdateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageUpdateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  auctions?: Maybe<AuctionUpdateManyWithoutSellerInput>;
  bids?: Maybe<BidUpdateManyWithoutBidderInput>;
  birdOwned?: Maybe<BirdUpdateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentUpdateManyInput>;
}

export interface BidUpdateManyMutationInput {
  amountBid?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface AuctionUpdateManyDataInput {
  openPrice?: Maybe<String>;
  closePrice?: Maybe<String>;
  incrementAmount?: Maybe<String>;
  startTime?: Maybe<String>;
  closeTime?: Maybe<String>;
  isClosed?: Maybe<Boolean>;
}

export interface CommentUpsertWithWhereUniqueWithoutAuctionInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuctionDataInput;
  create: CommentCreateWithoutAuctionInput;
}

export interface BidCreateInput {
  id?: Maybe<ID_Input>;
  auction: AuctionCreateOneInput;
  bidder: UserCreateOneWithoutBidsInput;
  amountBid: String;
  timeStamp: String;
}

export interface AuctionUpsertNestedInput {
  update: AuctionUpdateDataInput;
  create: AuctionCreateInput;
}

export interface BirdParentCreateInput {
  id?: Maybe<ID_Input>;
  noParent: String;
  breedingRecord?: Maybe<BreedingRecordCreateManyWithoutParentInput>;
  male: BirdCreateOneInput;
  female: BirdCreateOneInput;
}

export interface UserUpdateOneRequiredWithoutBidsInput {
  create?: Maybe<UserCreateWithoutBidsInput>;
  update?: Maybe<UserUpdateWithoutBidsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBidsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ImageUpdateInput {
  src?: Maybe<String>;
  description?: Maybe<String>;
}

export interface AuctionUpsertWithWhereUniqueWithoutSellerInput {
  where: AuctionWhereUniqueInput;
  update: AuctionUpdateWithoutSellerDataInput;
  create: AuctionCreateWithoutSellerInput;
}

export interface BidUpsertWithWhereUniqueNestedInput {
  where: BidWhereUniqueInput;
  update: BidUpdateDataInput;
  create: BidCreateInput;
}

export interface UserUpsertWithoutBidsInput {
  update: UserUpdateWithoutBidsDataInput;
  create: UserCreateWithoutBidsInput;
}

export interface UserUpdateWithoutBidsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  city?: Maybe<String>;
  location?: Maybe<String>;
  address?: Maybe<String>;
  phone?: Maybe<String>;
  journal?: Maybe<JournalUpdateOneInput>;
  birthday?: Maybe<String>;
  ktp?: Maybe<String>;
  ktpImage?: Maybe<ImageUpdateOneInput>;
  gender?: Maybe<String>;
  image?: Maybe<ImageUpdateOneInput>;
  auctions?: Maybe<AuctionUpdateManyWithoutSellerInput>;
  comments?: Maybe<CommentUpdateManyWithoutUserInput>;
  birdOwned?: Maybe<BirdUpdateManyWithoutOwnerInput>;
  birdParent?: Maybe<BirdParentUpdateManyInput>;
}

export interface BreedingLogUpdateManyMutationInput {
  type?: Maybe<String>;
  born?: Maybe<String>;
  dead?: Maybe<String>;
  timeStamp?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BreedingLogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BreedingLogWhereInput>;
  AND?: Maybe<
    BreedingLogSubscriptionWhereInput[] | BreedingLogSubscriptionWhereInput
  >;
  OR?: Maybe<
    BreedingLogSubscriptionWhereInput[] | BreedingLogSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BreedingLogSubscriptionWhereInput[] | BreedingLogSubscriptionWhereInput
  >;
}

export interface UserCreateOneWithoutAuctionsInput {
  create?: Maybe<UserCreateWithoutAuctionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface JournalCreateInput {
  id?: Maybe<ID_Input>;
  transaction?: Maybe<TransactionCreateOneInput>;
  balance?: Maybe<String>;
  timeStamp?: Maybe<String>;
}

export interface AuthPayloadUpdateInput {
  token?: Maybe<String>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
  city?: String;
  location?: String;
  address?: String;
  phone?: String;
  birthday?: String;
  ktp?: String;
  gender?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  city: () => Promise<String>;
  location: () => Promise<String>;
  address: () => Promise<String>;
  phone: () => Promise<String>;
  birthday: () => Promise<String>;
  ktp: () => Promise<String>;
  gender: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  ktp: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuthPayloadEdge {
  node: AuthPayload;
  cursor: String;
}

export interface AuthPayloadEdgePromise
  extends Promise<AuthPayloadEdge>,
    Fragmentable {
  node: <T = AuthPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthPayloadEdgeSubscription
  extends Promise<AsyncIterator<AuthPayloadEdge>>,
    Fragmentable {
  node: <T = AuthPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Bid {
  id: ID_Output;
  amountBid: String;
  timeStamp: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BidPromise extends Promise<Bid>, Fragmentable {
  id: () => Promise<ID_Output>;
  auction: <T = AuctionPromise>() => T;
  bidder: <T = UserPromise>() => T;
  amountBid: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BidSubscription
  extends Promise<AsyncIterator<Bid>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  auction: <T = AuctionSubscription>() => T;
  bidder: <T = UserSubscription>() => T;
  amountBid: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BidNullablePromise extends Promise<Bid | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  auction: <T = AuctionPromise>() => T;
  bidder: <T = UserPromise>() => T;
  amountBid: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AuthPayloadConnection {
  pageInfo: PageInfo;
  edges: AuthPayloadEdge[];
}

export interface AuthPayloadConnectionPromise
  extends Promise<AuthPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthPayloadEdge>>() => T;
  aggregate: <T = AggregateAuthPayloadPromise>() => T;
}

export interface AuthPayloadConnectionSubscription
  extends Promise<AsyncIterator<AuthPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthPayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthPayloadSubscription>() => T;
}

export interface Journal {
  id: ID_Output;
  balance?: String;
  timeStamp?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface JournalPromise extends Promise<Journal>, Fragmentable {
  id: () => Promise<ID_Output>;
  transaction: <T = TransactionPromise>() => T;
  balance: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface JournalSubscription
  extends Promise<AsyncIterator<Journal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transaction: <T = TransactionSubscription>() => T;
  balance: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JournalNullablePromise
  extends Promise<Journal | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transaction: <T = TransactionPromise>() => T;
  balance: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AuthPayload {
  id: ID_Output;
  token?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AuthPayloadPromise extends Promise<AuthPayload>, Fragmentable {
  id: () => Promise<ID_Output>;
  token: () => Promise<String>;
  user: <T = UserPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AuthPayloadSubscription
  extends Promise<AsyncIterator<AuthPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  token: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuthPayloadNullablePromise
  extends Promise<AuthPayload | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  token: () => Promise<String>;
  user: <T = UserPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateAuction {
  count: Int;
}

export interface AggregateAuctionPromise
  extends Promise<AggregateAuction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuctionSubscription
  extends Promise<AsyncIterator<AggregateAuction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuctionEdge {
  node: Auction;
  cursor: String;
}

export interface AuctionEdgePromise extends Promise<AuctionEdge>, Fragmentable {
  node: <T = AuctionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuctionEdgeSubscription
  extends Promise<AsyncIterator<AuctionEdge>>,
    Fragmentable {
  node: <T = AuctionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface Auction {
  id: ID_Output;
  openPrice: String;
  closePrice: String;
  incrementAmount: String;
  startTime: String;
  closeTime: String;
  isClosed: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AuctionPromise extends Promise<Auction>, Fragmentable {
  id: () => Promise<ID_Output>;
  bird: <T = BirdPromise>() => T;
  seller: <T = UserPromise>() => T;
  openPrice: () => Promise<String>;
  closePrice: () => Promise<String>;
  incrementAmount: () => Promise<String>;
  startTime: () => Promise<String>;
  closeTime: () => Promise<String>;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastBid: <T = BidPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isClosed: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AuctionSubscription
  extends Promise<AsyncIterator<Auction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bird: <T = BirdSubscription>() => T;
  seller: <T = UserSubscription>() => T;
  openPrice: () => Promise<AsyncIterator<String>>;
  closePrice: () => Promise<AsyncIterator<String>>;
  incrementAmount: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  closeTime: () => Promise<AsyncIterator<String>>;
  bids: <T = Promise<AsyncIterator<BidSubscription>>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastBid: <T = BidSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isClosed: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuctionNullablePromise
  extends Promise<Auction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bird: <T = BirdPromise>() => T;
  seller: <T = UserPromise>() => T;
  openPrice: () => Promise<String>;
  closePrice: () => Promise<String>;
  incrementAmount: () => Promise<String>;
  startTime: () => Promise<String>;
  closeTime: () => Promise<String>;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastBid: <T = BidPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isClosed: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateJournal {
  count: Int;
}

export interface AggregateJournalPromise
  extends Promise<AggregateJournal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJournalSubscription
  extends Promise<AsyncIterator<AggregateJournal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuctionSubscriptionPayload {
  mutation: MutationType;
  node: Auction;
  updatedFields: String[];
  previousValues: AuctionPreviousValues;
}

export interface AuctionSubscriptionPayloadPromise
  extends Promise<AuctionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuctionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuctionPreviousValuesPromise>() => T;
}

export interface AuctionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuctionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuctionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuctionPreviousValuesSubscription>() => T;
}

export interface JournalConnection {
  pageInfo: PageInfo;
  edges: JournalEdge[];
}

export interface JournalConnectionPromise
  extends Promise<JournalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JournalEdge>>() => T;
  aggregate: <T = AggregateJournalPromise>() => T;
}

export interface JournalConnectionSubscription
  extends Promise<AsyncIterator<JournalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JournalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJournalSubscription>() => T;
}

export interface AuctionPreviousValues {
  id: ID_Output;
  openPrice: String;
  closePrice: String;
  incrementAmount: String;
  startTime: String;
  closeTime: String;
  isClosed: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AuctionPreviousValuesPromise
  extends Promise<AuctionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  openPrice: () => Promise<String>;
  closePrice: () => Promise<String>;
  incrementAmount: () => Promise<String>;
  startTime: () => Promise<String>;
  closeTime: () => Promise<String>;
  isClosed: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AuctionPreviousValuesSubscription
  extends Promise<AsyncIterator<AuctionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  openPrice: () => Promise<AsyncIterator<String>>;
  closePrice: () => Promise<AsyncIterator<String>>;
  incrementAmount: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<String>>;
  closeTime: () => Promise<AsyncIterator<String>>;
  isClosed: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface AuthPayloadSubscriptionPayload {
  mutation: MutationType;
  node: AuthPayload;
  updatedFields: String[];
  previousValues: AuthPayloadPreviousValues;
}

export interface AuthPayloadSubscriptionPayloadPromise
  extends Promise<AuthPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthPayloadPreviousValuesPromise>() => T;
}

export interface AuthPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthPayloadPreviousValuesSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthPayloadPreviousValues {
  id: ID_Output;
  token?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AuthPayloadPreviousValuesPromise
  extends Promise<AuthPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  token: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AuthPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  token: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBreedingRecord {
  count: Int;
}

export interface AggregateBreedingRecordPromise
  extends Promise<AggregateBreedingRecord>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBreedingRecordSubscription
  extends Promise<AsyncIterator<AggregateBreedingRecord>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuctionConnection {
  pageInfo: PageInfo;
  edges: AuctionEdge[];
}

export interface AuctionConnectionPromise
  extends Promise<AuctionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuctionEdge>>() => T;
  aggregate: <T = AggregateAuctionPromise>() => T;
}

export interface AuctionConnectionSubscription
  extends Promise<AsyncIterator<AuctionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuctionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuctionSubscription>() => T;
}

export interface BreedingRecordConnection {
  pageInfo: PageInfo;
  edges: BreedingRecordEdge[];
}

export interface BreedingRecordConnectionPromise
  extends Promise<BreedingRecordConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BreedingRecordEdge>>() => T;
  aggregate: <T = AggregateBreedingRecordPromise>() => T;
}

export interface BreedingRecordConnectionSubscription
  extends Promise<AsyncIterator<BreedingRecordConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BreedingRecordEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBreedingRecordSubscription>() => T;
}

export interface BidSubscriptionPayload {
  mutation: MutationType;
  node: Bid;
  updatedFields: String[];
  previousValues: BidPreviousValues;
}

export interface BidSubscriptionPayloadPromise
  extends Promise<BidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BidPreviousValuesPromise>() => T;
}

export interface BidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BidPreviousValuesSubscription>() => T;
}

export interface BreedingLogEdge {
  node: BreedingLog;
  cursor: String;
}

export interface BreedingLogEdgePromise
  extends Promise<BreedingLogEdge>,
    Fragmentable {
  node: <T = BreedingLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BreedingLogEdgeSubscription
  extends Promise<AsyncIterator<BreedingLogEdge>>,
    Fragmentable {
  node: <T = BreedingLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BidPreviousValues {
  id: ID_Output;
  amountBid: String;
  timeStamp: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BidPreviousValuesPromise
  extends Promise<BidPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amountBid: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BidPreviousValuesSubscription
  extends Promise<AsyncIterator<BidPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amountBid: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBirdParent {
  count: Int;
}

export interface AggregateBirdParentPromise
  extends Promise<AggregateBirdParent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBirdParentSubscription
  extends Promise<AsyncIterator<AggregateBirdParent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Transaction {
  id: ID_Output;
  type?: String;
  decription?: String;
  amount?: String;
  timeStamp?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  decription: () => Promise<String>;
  amount: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  decription: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  decription: () => Promise<String>;
  amount: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BirdParentConnection {
  pageInfo: PageInfo;
  edges: BirdParentEdge[];
}

export interface BirdParentConnectionPromise
  extends Promise<BirdParentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BirdParentEdge>>() => T;
  aggregate: <T = AggregateBirdParentPromise>() => T;
}

export interface BirdParentConnectionSubscription
  extends Promise<AsyncIterator<BirdParentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BirdParentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBirdParentSubscription>() => T;
}

export interface BirdSubscriptionPayload {
  mutation: MutationType;
  node: Bird;
  updatedFields: String[];
  previousValues: BirdPreviousValues;
}

export interface BirdSubscriptionPayloadPromise
  extends Promise<BirdSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BirdPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BirdPreviousValuesPromise>() => T;
}

export interface BirdSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BirdSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BirdSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BirdPreviousValuesSubscription>() => T;
}

export interface BirdEdge {
  node: Bird;
  cursor: String;
}

export interface BirdEdgePromise extends Promise<BirdEdge>, Fragmentable {
  node: <T = BirdPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BirdEdgeSubscription
  extends Promise<AsyncIterator<BirdEdge>>,
    Fragmentable {
  node: <T = BirdSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BirdPreviousValues {
  id: ID_Output;
  name?: String;
  ring: String;
  breeder: String;
  species: String;
  type: String;
  gender: String;
  age: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BirdPreviousValuesPromise
  extends Promise<BirdPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  ring: () => Promise<String>;
  breeder: () => Promise<String>;
  species: () => Promise<String>;
  type: () => Promise<String>;
  gender: () => Promise<String>;
  age: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BirdPreviousValuesSubscription
  extends Promise<AsyncIterator<BirdPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  ring: () => Promise<AsyncIterator<String>>;
  breeder: () => Promise<AsyncIterator<String>>;
  species: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBid {
  count: Int;
}

export interface AggregateBidPromise
  extends Promise<AggregateBid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBidSubscription
  extends Promise<AsyncIterator<AggregateBid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BreedingLog {
  id: ID_Output;
  type?: String;
  born?: String;
  dead?: String;
  timeStamp: String;
  description: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BreedingLogPromise extends Promise<BreedingLog>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  born: () => Promise<String>;
  dead: () => Promise<String>;
  timeStamp: () => Promise<String>;
  description: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BreedingLogSubscription
  extends Promise<AsyncIterator<BreedingLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  born: () => Promise<AsyncIterator<String>>;
  dead: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BreedingLogNullablePromise
  extends Promise<BreedingLog | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  born: () => Promise<String>;
  dead: () => Promise<String>;
  timeStamp: () => Promise<String>;
  description: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BidConnection {
  pageInfo: PageInfo;
  edges: BidEdge[];
}

export interface BidConnectionPromise
  extends Promise<BidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BidEdge>>() => T;
  aggregate: <T = AggregateBidPromise>() => T;
}

export interface BidConnectionSubscription
  extends Promise<AsyncIterator<BidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBidSubscription>() => T;
}

export interface BirdParentSubscriptionPayload {
  mutation: MutationType;
  node: BirdParent;
  updatedFields: String[];
  previousValues: BirdParentPreviousValues;
}

export interface BirdParentSubscriptionPayloadPromise
  extends Promise<BirdParentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BirdParentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BirdParentPreviousValuesPromise>() => T;
}

export interface BirdParentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BirdParentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BirdParentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BirdParentPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BirdParentPreviousValues {
  id: ID_Output;
  noParent: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BirdParentPreviousValuesPromise
  extends Promise<BirdParentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  noParent: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BirdParentPreviousValuesSubscription
  extends Promise<AsyncIterator<BirdParentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  noParent: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  type?: String;
  decription?: String;
  amount?: String;
  timeStamp?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  decription: () => Promise<String>;
  amount: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  decription: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BreedingLogSubscriptionPayload {
  mutation: MutationType;
  node: BreedingLog;
  updatedFields: String[];
  previousValues: BreedingLogPreviousValues;
}

export interface BreedingLogSubscriptionPayloadPromise
  extends Promise<BreedingLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BreedingLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BreedingLogPreviousValuesPromise>() => T;
}

export interface BreedingLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BreedingLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BreedingLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BreedingLogPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
  city?: String;
  location?: String;
  address?: String;
  phone?: String;
  birthday?: String;
  ktp?: String;
  gender?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  city: () => Promise<String>;
  location: () => Promise<String>;
  address: () => Promise<String>;
  phone: () => Promise<String>;
  journal: <T = JournalPromise>() => T;
  birthday: () => Promise<String>;
  ktp: () => Promise<String>;
  ktpImage: <T = ImagePromise>() => T;
  gender: () => Promise<String>;
  image: <T = ImagePromise>() => T;
  auctions: <T = FragmentableArray<Auction>>(args?: {
    where?: AuctionWhereInput;
    orderBy?: AuctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birdOwned: <T = FragmentableArray<Bird>>(args?: {
    where?: BirdWhereInput;
    orderBy?: BirdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birdParent: <T = FragmentableArray<BirdParent>>(args?: {
    where?: BirdParentWhereInput;
    orderBy?: BirdParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  journal: <T = JournalSubscription>() => T;
  birthday: () => Promise<AsyncIterator<String>>;
  ktp: () => Promise<AsyncIterator<String>>;
  ktpImage: <T = ImageSubscription>() => T;
  gender: () => Promise<AsyncIterator<String>>;
  image: <T = ImageSubscription>() => T;
  auctions: <T = Promise<AsyncIterator<AuctionSubscription>>>(args?: {
    where?: AuctionWhereInput;
    orderBy?: AuctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = Promise<AsyncIterator<BidSubscription>>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birdOwned: <T = Promise<AsyncIterator<BirdSubscription>>>(args?: {
    where?: BirdWhereInput;
    orderBy?: BirdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birdParent: <T = Promise<AsyncIterator<BirdParentSubscription>>>(args?: {
    where?: BirdParentWhereInput;
    orderBy?: BirdParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  city: () => Promise<String>;
  location: () => Promise<String>;
  address: () => Promise<String>;
  phone: () => Promise<String>;
  journal: <T = JournalPromise>() => T;
  birthday: () => Promise<String>;
  ktp: () => Promise<String>;
  ktpImage: <T = ImagePromise>() => T;
  gender: () => Promise<String>;
  image: <T = ImagePromise>() => T;
  auctions: <T = FragmentableArray<Auction>>(args?: {
    where?: AuctionWhereInput;
    orderBy?: AuctionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birdOwned: <T = FragmentableArray<Bird>>(args?: {
    where?: BirdWhereInput;
    orderBy?: BirdOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  birdParent: <T = FragmentableArray<BirdParent>>(args?: {
    where?: BirdParentWhereInput;
    orderBy?: BirdParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BreedingLogPreviousValues {
  id: ID_Output;
  type?: String;
  born?: String;
  dead?: String;
  timeStamp: String;
  description: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BreedingLogPreviousValuesPromise
  extends Promise<BreedingLogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  born: () => Promise<String>;
  dead: () => Promise<String>;
  timeStamp: () => Promise<String>;
  description: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BreedingLogPreviousValuesSubscription
  extends Promise<AsyncIterator<BreedingLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  born: () => Promise<AsyncIterator<String>>;
  dead: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BreedingRecord {
  id: ID_Output;
  name?: String;
  status?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BreedingRecordPromise
  extends Promise<BreedingRecord>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  status: () => Promise<String>;
  parent: <T = BirdParentPromise>() => T;
  log: <T = FragmentableArray<BreedingLog>>(args?: {
    where?: BreedingLogWhereInput;
    orderBy?: BreedingLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BreedingRecordSubscription
  extends Promise<AsyncIterator<BreedingRecord>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  parent: <T = BirdParentSubscription>() => T;
  log: <T = Promise<AsyncIterator<BreedingLogSubscription>>>(args?: {
    where?: BreedingLogWhereInput;
    orderBy?: BreedingLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BreedingRecordNullablePromise
  extends Promise<BreedingRecord | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  status: () => Promise<String>;
  parent: <T = BirdParentPromise>() => T;
  log: <T = FragmentableArray<BreedingLog>>(args?: {
    where?: BreedingLogWhereInput;
    orderBy?: BreedingLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BreedingRecordEdge {
  node: BreedingRecord;
  cursor: String;
}

export interface BreedingRecordEdgePromise
  extends Promise<BreedingRecordEdge>,
    Fragmentable {
  node: <T = BreedingRecordPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BreedingRecordEdgeSubscription
  extends Promise<AsyncIterator<BreedingRecordEdge>>,
    Fragmentable {
  node: <T = BreedingRecordSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BreedingRecordSubscriptionPayload {
  mutation: MutationType;
  node: BreedingRecord;
  updatedFields: String[];
  previousValues: BreedingRecordPreviousValues;
}

export interface BreedingRecordSubscriptionPayloadPromise
  extends Promise<BreedingRecordSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BreedingRecordPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BreedingRecordPreviousValuesPromise>() => T;
}

export interface BreedingRecordSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BreedingRecordSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BreedingRecordSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BreedingRecordPreviousValuesSubscription>() => T;
}

export interface BreedingLogConnection {
  pageInfo: PageInfo;
  edges: BreedingLogEdge[];
}

export interface BreedingLogConnectionPromise
  extends Promise<BreedingLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BreedingLogEdge>>() => T;
  aggregate: <T = AggregateBreedingLogPromise>() => T;
}

export interface BreedingLogConnectionSubscription
  extends Promise<AsyncIterator<BreedingLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BreedingLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBreedingLogSubscription>() => T;
}

export interface BreedingRecordPreviousValues {
  id: ID_Output;
  name?: String;
  status?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BreedingRecordPreviousValuesPromise
  extends Promise<BreedingRecordPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  status: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BreedingRecordPreviousValuesSubscription
  extends Promise<AsyncIterator<BreedingRecordPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBird {
  count: Int;
}

export interface AggregateBirdPromise
  extends Promise<AggregateBird>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBirdSubscription
  extends Promise<AsyncIterator<AggregateBird>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Image {
  id: ID_Output;
  src: String;
  description: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  description: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  src: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  description: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BidEdge {
  node: Bid;
  cursor: String;
}

export interface BidEdgePromise extends Promise<BidEdge>, Fragmentable {
  node: <T = BidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BidEdgeSubscription
  extends Promise<AsyncIterator<BidEdge>>,
    Fragmentable {
  node: <T = BidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface Bird {
  id: ID_Output;
  name?: String;
  ring: String;
  breeder: String;
  species: String;
  type: String;
  gender: String;
  age: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BirdPromise extends Promise<Bird>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  ring: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  breeder: () => Promise<String>;
  species: () => Promise<String>;
  type: () => Promise<String>;
  gender: () => Promise<String>;
  age: () => Promise<String>;
  image: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = BirdParentPromise>() => T;
  dna: <T = ImagePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BirdSubscription
  extends Promise<AsyncIterator<Bird>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  ring: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  breeder: () => Promise<AsyncIterator<String>>;
  species: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<String>>;
  image: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = BirdParentSubscription>() => T;
  dna: <T = ImageSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BirdNullablePromise
  extends Promise<Bird | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  ring: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  breeder: () => Promise<String>;
  species: () => Promise<String>;
  type: () => Promise<String>;
  gender: () => Promise<String>;
  age: () => Promise<String>;
  image: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  parent: <T = BirdParentPromise>() => T;
  dna: <T = ImagePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValues {
  id: ID_Output;
  message: String;
  timeStamp: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JournalEdge {
  node: Journal;
  cursor: String;
}

export interface JournalEdgePromise extends Promise<JournalEdge>, Fragmentable {
  node: <T = JournalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JournalEdgeSubscription
  extends Promise<AsyncIterator<JournalEdge>>,
    Fragmentable {
  node: <T = JournalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BirdParent {
  id: ID_Output;
  noParent: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface BirdParentPromise extends Promise<BirdParent>, Fragmentable {
  id: () => Promise<ID_Output>;
  noParent: () => Promise<String>;
  breedingRecord: <T = FragmentableArray<BreedingRecord>>(args?: {
    where?: BreedingRecordWhereInput;
    orderBy?: BreedingRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  male: <T = BirdPromise>() => T;
  female: <T = BirdPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BirdParentSubscription
  extends Promise<AsyncIterator<BirdParent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  noParent: () => Promise<AsyncIterator<String>>;
  breedingRecord: <
    T = Promise<AsyncIterator<BreedingRecordSubscription>>
  >(args?: {
    where?: BreedingRecordWhereInput;
    orderBy?: BreedingRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  male: <T = BirdSubscription>() => T;
  female: <T = BirdSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BirdParentNullablePromise
  extends Promise<BirdParent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  noParent: () => Promise<String>;
  breedingRecord: <T = FragmentableArray<BreedingRecord>>(args?: {
    where?: BreedingRecordWhereInput;
    orderBy?: BreedingRecordOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  male: <T = BirdPromise>() => T;
  female: <T = BirdPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface BirdParentEdge {
  node: BirdParent;
  cursor: String;
}

export interface BirdParentEdgePromise
  extends Promise<BirdParentEdge>,
    Fragmentable {
  node: <T = BirdParentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BirdParentEdgeSubscription
  extends Promise<AsyncIterator<BirdParentEdge>>,
    Fragmentable {
  node: <T = BirdParentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAuthPayload {
  count: Int;
}

export interface AggregateAuthPayloadPromise
  extends Promise<AggregateAuthPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthPayloadSubscription
  extends Promise<AsyncIterator<AggregateAuthPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JournalPreviousValues {
  id: ID_Output;
  balance?: String;
  timeStamp?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface JournalPreviousValuesPromise
  extends Promise<JournalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  balance: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface JournalPreviousValuesSubscription
  extends Promise<AsyncIterator<JournalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  balance: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JournalSubscriptionPayload {
  mutation: MutationType;
  node: Journal;
  updatedFields: String[];
  previousValues: JournalPreviousValues;
}

export interface JournalSubscriptionPayloadPromise
  extends Promise<JournalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JournalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JournalPreviousValuesPromise>() => T;
}

export interface JournalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JournalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JournalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JournalPreviousValuesSubscription>() => T;
}

export interface Comment {
  id: ID_Output;
  message: String;
  timeStamp: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  auction: <T = AuctionPromise>() => T;
  message: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  auction: <T = AuctionSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  timeStamp: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  auction: <T = AuctionPromise>() => T;
  message: () => Promise<String>;
  timeStamp: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValues {
  id: ID_Output;
  src: String;
  description: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  description: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  src: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BirdConnection {
  pageInfo: PageInfo;
  edges: BirdEdge[];
}

export interface BirdConnectionPromise
  extends Promise<BirdConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BirdEdge>>() => T;
  aggregate: <T = AggregateBirdPromise>() => T;
}

export interface BirdConnectionSubscription
  extends Promise<AsyncIterator<BirdConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BirdEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBirdSubscription>() => T;
}

export interface AggregateBreedingLog {
  count: Int;
}

export interface AggregateBreedingLogPromise
  extends Promise<AggregateBreedingLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBreedingLogSubscription
  extends Promise<AsyncIterator<AggregateBreedingLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Journal",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "Bird",
    embedded: false
  },
  {
    name: "BirdParent",
    embedded: false
  },
  {
    name: "BreedingRecord",
    embedded: false
  },
  {
    name: "BreedingLog",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Auction",
    embedded: false
  },
  {
    name: "Bid",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "AuthPayload",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
